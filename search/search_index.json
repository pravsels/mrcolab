{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Ubiq Ubiq is a Unity networking library, for research, teaching and development. Ubiq is built and maintained by the Virtual Environments and Computer Graphics group at University College London. Ubiq is 100% free and open source. Features Ubiq's goal is to enable your networked project. It includes message passing, room management, rendezvous and matchmaking, object spawning, shared binary blobs, multiple synchronisation models, lighweight XR interaction examples, customisable avatars and voice chat across Windows, Linux, Android, MacOS, and Javascript running in the browser. For Researchers Instructions for setting up your own server are included. Ubiq does not rely on any third-party services, making it GDPR-safe for your experiments.","title":"Home"},{"location":"#welcome-to-ubiq","text":"Ubiq is a Unity networking library, for research, teaching and development. Ubiq is built and maintained by the Virtual Environments and Computer Graphics group at University College London. Ubiq is 100% free and open source.","title":"Welcome to Ubiq"},{"location":"#features","text":"Ubiq's goal is to enable your networked project. It includes message passing, room management, rendezvous and matchmaking, object spawning, shared binary blobs, multiple synchronisation models, lighweight XR interaction examples, customisable avatars and voice chat across Windows, Linux, Android, MacOS, and Javascript running in the browser.","title":"Features"},{"location":"#for-researchers","text":"Instructions for setting up your own server are included. Ubiq does not rely on any third-party services, making it GDPR-safe for your experiments.","title":"For Researchers"},{"location":"asyncdesignpatterns/","text":"Asyncrhonous Design Patterns in Unity The Unity process manages the main thread, which begins before any user code is executed. Most Unity resources can only be accessed from the main thread; an exception will be thrown otherwise. There are still many possibilities for writing aysnchronous code however. Design Pattern Delayed initialisation with callbacks. Mimics the do-then pattern in JS. Methods are called which take Actions. Those Actions are initialised by lambdas. The lambas execution thread depends on the called function. void Start() { factory.GetRtcConfiguration(config => { pc = factory.CreatePeerConnection(config, this); }); } Design Pattern Message pumps with Update. Commonly used in the mid-level networking code, this pattern uses a list of actions to execute methods on the main thread. class NetworkScene { private List<Action> actions = new List<Action>(); public void RegisterComponent(INetworkComponent component) { actions.Add(() => { if (!objectProperties.ContainsKey(networkObject)) { objectProperties.Add(networkObject, new ObjectProperties() { identity = networkObject, scene = this, }); } }); } private void Update() { ReceiveConnectionMessages(); foreach (var action in actions) { action(); } actions.Clear(); } } Design Pattern Commonly used in webrtc code for objects that take time to initialise because they are waiting on external resources. This pattern uses coroutines to effectively poll a resource, conditionally executing operations on the main thread. void Start() { factory.GetRtcConfiguration(config => { pc = factory.CreatePeerConnection(config, this); }); } private IEnumerator WaitForPeerConnection(Action OnPcCreated) { while (pc == null) { yield return null; } OnPcCreated(); } public void AddLocalAudioSource() { StartCoroutine(WaitForPeerConnection(() => { var audiosource = factory.CreateAudioSource(); var audiotrack = factory.CreateAudioTrack(\"localAudioSource\", audiosource); pc.AddTrack(audiotrack, new[] { \"localAudioSource\" }); })); }","title":"Async Design Patterns"},{"location":"asyncdesignpatterns/#asyncrhonous-design-patterns-in-unity","text":"The Unity process manages the main thread, which begins before any user code is executed. Most Unity resources can only be accessed from the main thread; an exception will be thrown otherwise. There are still many possibilities for writing aysnchronous code however.","title":"Asyncrhonous Design Patterns in Unity"},{"location":"asyncdesignpatterns/#design-pattern","text":"Delayed initialisation with callbacks. Mimics the do-then pattern in JS. Methods are called which take Actions. Those Actions are initialised by lambdas. The lambas execution thread depends on the called function. void Start() { factory.GetRtcConfiguration(config => { pc = factory.CreatePeerConnection(config, this); }); }","title":"Design Pattern"},{"location":"asyncdesignpatterns/#design-pattern_1","text":"Message pumps with Update. Commonly used in the mid-level networking code, this pattern uses a list of actions to execute methods on the main thread. class NetworkScene { private List<Action> actions = new List<Action>(); public void RegisterComponent(INetworkComponent component) { actions.Add(() => { if (!objectProperties.ContainsKey(networkObject)) { objectProperties.Add(networkObject, new ObjectProperties() { identity = networkObject, scene = this, }); } }); } private void Update() { ReceiveConnectionMessages(); foreach (var action in actions) { action(); } actions.Clear(); } }","title":"Design Pattern"},{"location":"asyncdesignpatterns/#design-pattern_2","text":"Commonly used in webrtc code for objects that take time to initialise because they are waiting on external resources. This pattern uses coroutines to effectively poll a resource, conditionally executing operations on the main thread. void Start() { factory.GetRtcConfiguration(config => { pc = factory.CreatePeerConnection(config, this); }); } private IEnumerator WaitForPeerConnection(Action OnPcCreated) { while (pc == null) { yield return null; } OnPcCreated(); } public void AddLocalAudioSource() { StartCoroutine(WaitForPeerConnection(() => { var audiosource = factory.CreateAudioSource(); var audiotrack = factory.CreateAudioTrack(\"localAudioSource\", audiosource); pc.AddTrack(audiotrack, new[] { \"localAudioSource\" }); })); }","title":"Design Pattern"},{"location":"creatinganetworkedobject/","text":"Building a Basic Networked Object Create a new Unity Script and add it to your GameObject that you want to have networked. You can do this via the inspector by clicking on \"Add Component\" and typing the new name. Include Ubik.Messaging Inherit from INetworkObject and INetworkComponent Implement their interfaces In Visual Studio this can be done through the context menu. Right Click -\\> Quick Actions and Refactoring -\\> Implement interface Note: This will only give you the stubs. You will need to fill them in yourself in the next steps Implement Network ID creation Register your networked object with the network Scene This should be done at the start of the objects life i.e. in the Start() function. If you want to send messages as well, you also need to save the context object that is returned. Define how your message will look like. This is best done as a struct in the class. It being defined in the class prevents naming conflict. In the message, write the variables that you want to send. A good start is TransformMessage that is built to store the transform and is useful if you want your object's location and orientation to be synchronised. Do not forget the constructor! It allows to create the message in one line. Receiving Messages Messages are received automatically. However, you will have to define how they are processed. For that, fill in ProcessMessage(\u2026) The first step is usually \"decoding\" the message. Usually it will be sent as a JSON, but if you send it in a different format, you need to decode it differently as well. Sending Messages You can send messages at any time and anywhere in the code through using your context object. However, most of the time you will probably want that the objects move in sync, so it makes sense to send an update each frame. For this, put your sending in Update(\u2026).","title":"Creating Networked Objects"},{"location":"creatinganetworkedobject/#building-a-basic-networked-object","text":"Create a new Unity Script and add it to your GameObject that you want to have networked. You can do this via the inspector by clicking on \"Add Component\" and typing the new name. Include Ubik.Messaging Inherit from INetworkObject and INetworkComponent Implement their interfaces In Visual Studio this can be done through the context menu. Right Click -\\> Quick Actions and Refactoring -\\> Implement interface Note: This will only give you the stubs. You will need to fill them in yourself in the next steps Implement Network ID creation Register your networked object with the network Scene This should be done at the start of the objects life i.e. in the Start() function. If you want to send messages as well, you also need to save the context object that is returned. Define how your message will look like. This is best done as a struct in the class. It being defined in the class prevents naming conflict. In the message, write the variables that you want to send. A good start is TransformMessage that is built to store the transform and is useful if you want your object's location and orientation to be synchronised. Do not forget the constructor! It allows to create the message in one line. Receiving Messages Messages are received automatically. However, you will have to define how they are processed. For that, fill in ProcessMessage(\u2026) The first step is usually \"decoding\" the message. Usually it will be sent as a JSON, but if you send it in a different format, you need to decode it differently as well. Sending Messages You can send messages at any time and anywhere in the code through using your context object. However, most of the time you will probably want that the objects move in sync, so it makes sense to send an update each frame. For this, put your sending in Update(\u2026).","title":"Building a Basic Networked Object"},{"location":"eventloganalysis/","text":"Analysis The Event Logger outputs structured logs, as Json objects. These can be processed on any platform that can read Json files. A sample log file is shown below. [ {\"ticks\":637599657099341295,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"0112f691-0c94838b\",\"arg2\":\"DESKTOP-F1J0MRR\",\"arg3\":\"System Product Name (ASUS)\",\"arg4\":\"f73fe01b1e21031d49274a1491d1d6b5714c92e9\"}, {\"ticks\":637599657429701260,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"0112f691-0c94838b\",\"objectid\":\"0112f691-0c94838b\",\"componentid\":50,\"event\":\"CreatePeerConnectionForRequest\",\"arg1\":\"7a577253-a3a38c7f\"}, {\"ticks\":637599657364232680,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"53c9dddd-a62bb937\",\"arg2\":\"Oculus Quest\",\"arg3\":\"Oculus Quest\",\"arg4\":\"b8db4746286db62ecad4c6fa13f17ab6\"}, {\"ticks\":637599657421868190,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"53c9dddd-a62bb937\",\"objectid\":\"53c9dddd-a62bb937\",\"componentid\":50,\"event\":\"CreatePeerConnectionForPeer\",\"arg1\":\"7a577253-a3a38c7f\",\"arg2\":\"0112f691-0c94838b\"}, {\"ticks\":637599657422314320,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"53c9dddd-a62bb937\",\"objectid\":\"53c9dddd-a62bb937\",\"componentid\":50,\"event\":\"RequestPeerConnection\",\"arg1\":\"7a577253-a3a38c7f\",\"arg2\":\"0112f691-0c94838b\"} ] In this example, two peers - a desktop PC (Unity Editor) and an Oculus Quest - join a room. The NetworkScene and VoipPeerConnectionManager both log events. To collect these logs, a new LogCollector was added to a new GameObject and the Start Collection button pressed. Some Json members are defined by the Logger type. For example, the ContextLogger writes the sceneid and objectid of the context passed to it on creation. The arg members correspond to those passed to the Log() method. Python Python can be used to analys logs programmatically. The Jupyter notebook below shows how to import and process logs using Pandas , a powerful data analysis library for Python. See the Notebook in full Download Jupyter Notebook Download Example Log File Excel Structured event logs are amenable to being viewed in a table. Microsoft Excel PowerQuery can import Json files and load events into Excel Worksheets. To do this: Open a new Workbook From the Data tab, choose Get Data -> From File -> From Json Open the log file, for example Application_log_2021-04-23-10-56-03_0.json Select the List header and click Convert To Table . This will instruct Excel to treat each entry as a row. Leave the Default Values in place and Click OK . The View will now appear as a Column . Use the button in the top right to add the Expand Column step. This will split each record into a set of columns. Make sure to click Load More... if visible to ensure you get every possible field in the table. Click OK Click Close & Load to build your table. You can now order by Ticks, and filter columns such as Events. Matlab Like Python, Matlab can load Json using the jsondecode function. % Read the text file and use jsondecode to produce a cell array of % structures. J = jsondecode(fileread(\"Application_Log.json\")); % The structures will have different fields, so we must use loops to filter % them as they cannot be combined into a single struct array or table. % Below, find all the events of type SpawnObject, and combine them into a % new array. spawn = []; for j = J' % The curly braces access the contents of the cell j, which is the % struct. s = j{1}; if categorical(cellstr(s.event)) == categorical(\"SpawnObject\") spawn = [spawn; s]; end end % Convert the new array into a table T = struct2table(spawn); % Use the table to change the type of the sceneid column so we can easily % split the events by which peer they are from. T.sceneid = categorical(T.sceneid); % Filter the events to keep only those at the spawner T = T(T.arg3,:); % Plot the number of objects spawned over time, for each Peer figure; hold all; peers = unique(T.sceneid); for p = peers' spawned = T(T.sceneid == p,:); plot(spawned.ticks,1:size(spawned,1)); end xlabel(\"Time (ticks)\"); ylabel(\"Number of Objects\"); legend(peers); Download Matlab Source Download Example Log File","title":"Analysis"},{"location":"eventloganalysis/#analysis","text":"The Event Logger outputs structured logs, as Json objects. These can be processed on any platform that can read Json files. A sample log file is shown below. [ {\"ticks\":637599657099341295,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"0112f691-0c94838b\",\"arg2\":\"DESKTOP-F1J0MRR\",\"arg3\":\"System Product Name (ASUS)\",\"arg4\":\"f73fe01b1e21031d49274a1491d1d6b5714c92e9\"}, {\"ticks\":637599657429701260,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"0112f691-0c94838b\",\"objectid\":\"0112f691-0c94838b\",\"componentid\":50,\"event\":\"CreatePeerConnectionForRequest\",\"arg1\":\"7a577253-a3a38c7f\"}, {\"ticks\":637599657364232680,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"53c9dddd-a62bb937\",\"arg2\":\"Oculus Quest\",\"arg3\":\"Oculus Quest\",\"arg4\":\"b8db4746286db62ecad4c6fa13f17ab6\"}, {\"ticks\":637599657421868190,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"53c9dddd-a62bb937\",\"objectid\":\"53c9dddd-a62bb937\",\"componentid\":50,\"event\":\"CreatePeerConnectionForPeer\",\"arg1\":\"7a577253-a3a38c7f\",\"arg2\":\"0112f691-0c94838b\"}, {\"ticks\":637599657422314320,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"53c9dddd-a62bb937\",\"objectid\":\"53c9dddd-a62bb937\",\"componentid\":50,\"event\":\"RequestPeerConnection\",\"arg1\":\"7a577253-a3a38c7f\",\"arg2\":\"0112f691-0c94838b\"} ] In this example, two peers - a desktop PC (Unity Editor) and an Oculus Quest - join a room. The NetworkScene and VoipPeerConnectionManager both log events. To collect these logs, a new LogCollector was added to a new GameObject and the Start Collection button pressed. Some Json members are defined by the Logger type. For example, the ContextLogger writes the sceneid and objectid of the context passed to it on creation. The arg members correspond to those passed to the Log() method.","title":"Analysis"},{"location":"eventloganalysis/#python","text":"Python can be used to analys logs programmatically. The Jupyter notebook below shows how to import and process logs using Pandas , a powerful data analysis library for Python. See the Notebook in full Download Jupyter Notebook Download Example Log File","title":"Python"},{"location":"eventloganalysis/#excel","text":"Structured event logs are amenable to being viewed in a table. Microsoft Excel PowerQuery can import Json files and load events into Excel Worksheets. To do this: Open a new Workbook From the Data tab, choose Get Data -> From File -> From Json Open the log file, for example Application_log_2021-04-23-10-56-03_0.json Select the List header and click Convert To Table . This will instruct Excel to treat each entry as a row. Leave the Default Values in place and Click OK . The View will now appear as a Column . Use the button in the top right to add the Expand Column step. This will split each record into a set of columns. Make sure to click Load More... if visible to ensure you get every possible field in the table. Click OK Click Close & Load to build your table. You can now order by Ticks, and filter columns such as Events.","title":"Excel"},{"location":"eventloganalysis/#matlab","text":"Like Python, Matlab can load Json using the jsondecode function. % Read the text file and use jsondecode to produce a cell array of % structures. J = jsondecode(fileread(\"Application_Log.json\")); % The structures will have different fields, so we must use loops to filter % them as they cannot be combined into a single struct array or table. % Below, find all the events of type SpawnObject, and combine them into a % new array. spawn = []; for j = J' % The curly braces access the contents of the cell j, which is the % struct. s = j{1}; if categorical(cellstr(s.event)) == categorical(\"SpawnObject\") spawn = [spawn; s]; end end % Convert the new array into a table T = struct2table(spawn); % Use the table to change the type of the sceneid column so we can easily % split the events by which peer they are from. T.sceneid = categorical(T.sceneid); % Filter the events to keep only those at the spawner T = T(T.arg3,:); % Plot the number of objects spawned over time, for each Peer figure; hold all; peers = unique(T.sceneid); for p = peers' spawned = T(T.sceneid == p,:); plot(spawned.ticks,1:size(spawned,1)); end xlabel(\"Time (ticks)\"); ylabel(\"Number of Objects\"); legend(peers); Download Matlab Source Download Example Log File","title":"Matlab"},{"location":"eventlogging/","text":"Introduction Networked VR applications require different types of logging, such as: Debug Logs Experiment Logs Network Traces Refers to logging expected and exceptional events that occur during a regular session. The purpose is post-hoc debugging of high-level application code. Refers to logging application-specific data, such as measurements or questionnaire responses for an experiment. Refers to captures of network traffic to investigate reproducible low-level netcode bugs. (1) & (2) are handled by Ubiq's Event Logging system. (3) has distinct performance implications, so is handled seperately. Use Case The Event Logging System is for collecting low or medium frequency events from multiple peers. The Event Logging system can log both Ubiq and third-party events, which can then be extracted and analysed. Events are discrete, but otherwise have very few restrictions. It is up to the user to ensure that event logging in their application doesn't negatively affect performance. Overview Events are generated by EventLogger instances placed throughout the application. Events generated by these components are passed to a LogManager instance. The LogManager forwards all events in an application to a LogCollector , and the LogCollector writes them to disk (or database, or other endpoint). LogManager and LogCollector can be on the same machine or separated by the network. EventLogger EventLogger instances are lightweight objects that the application uses to log events. Calls to an EventLogger are expected to be placed throughout the system persistently, rather than gated with pre-processor defines. The most common types of event logger are the ContextEventLogger , which is designed to work with Components that have a NetworkContext , and the UserEventLogger , designed for logging measurements in experiments. public class VoipPeerConnectionManager : MonoBehaviour, INetworkComponent { private EventLogger logger; private void Start() { context = NetworkScene.Register(this); logger = new ContextEventLogger(context); } public void ProcessMessage(ReferenceCountedSceneGraphMessage message) { var msg = JsonUtility.FromJson<Message>(message.ToString()); switch (msg.type) { case \"RequestPeerConnection\": logger.Log(\"CreatePeerConnectionForRequest\", msg.objectid); break; } } } The snippet above demonstrates the creation and use of a ContextEventLogger . The VoipPeerConnectionManager declares the logger and initialises it with a ContextEventLogger once a context has been created. The Log method can then be called to log the receipt of a specific message. EventLogger instances attach to a single LogManager . Event logger constructors find the closest LogManager automatically. EventLogger methods can be safely called from outside the Unity main thread. They should not be called from outside CLR threads however. EventLogger instances are designed to have zero overhead when logs are not actually written. The Log method has many overloads to avoid boxing, and serialisation only runs when logging is on. Logs are only written when there is a listening LogManager in the scene. It is encouraged to make as many EventLogger instances as needed. Individual event loggers are simple, with few options. Use multiple EventLogger instances within a class to get fine-grained control over logging, for example different log levels. User and Application Events An EventLogger can tag events as Application or User events. The LogManager can forward either or both types of event. The LogCollector will have different endpoints for different tags. In the case of the default LogCollector , events will be written to different files. The purpose is to make using the Event Logging System for experiments easier, by acknowledging that for such applications, generating log outputs are the primary purpose, and that such outputs are distinct from those used to debug and develop it. ComponentEventLogger and ContextEventLogger have their type set to Application by default, whereas the UserEventLogger has its type set to User . The type for all EventLogger instances can be overridden at any time. All Ubiq events are of the type Application . The distinction between Application and User is not between Ubiq code and user code, but the purpose of the log; it is expected user applications will output both types, depending on their purpose. LogManager When a LogManager is placed in a scene, it will recieve events from nearby event loggers. By default the LogManager will cache events up to a limit (50 Mb worth), dropping older events as new ones are receieved. LogManager can also be set to store an infinite number of events, which may be desirable for experiments if the limit may be reached before a LogCollector is created. There are no bounds on how much memory it may consume in this mode however, up to and including triggering out of memory exceptions for the whole application. When instructed, the LogManager will forward these events and any new ones to a LogCollector , the Component that actually writes the logs to an endpoint such as the disk, or database. Each Peer must have at least one LogManager to emit log events; event loggers cannot communicate over the network themselves. Only one LogCollector is needed between all Peers, though multiple collectors may be present (in which case all will receive all events). At least one LogCollector must be present in the network for logs to be written; a LogManager can cache logs but it cannot write them anywhere. Filtering of User and Application events is done at the LogManager . If a LogManager does not listen for a type of event, it is the equivalent of not having a LogManager in the scene for an EventLogger of that type. LogCollector LogCollector instances receive events from LogManager instances and write them to an appropriate location. LogCollector instances can also control LogManager instances remotely - for example, starting and stopping the transmission of events. A single LogCollector receives all event types; filtering can only occur at the LogManager . The current implementation of the LogCollector writes events with different types to different files in the Persistent Data folder of whatever platform it is running on. Events are written as Json (Utf8 strings). The files themselves are Json compliant, with events being placed in a top-level Json Array . Local Log Collection LogCollector instances will automatically recieve events sent over the network, but will also receive events from LogManager instances on the same peer, even without a network connection. LogCollector instances will find all LogManager instances at the local Peer and register them on start-up. If a LogManager is instantiated in the Root of the scene, it will find all LogManager instances in the scene. If it is instantiated in a branch of the scene, it will find all LogManager instances within that branch. This allows logging events entirely on one machine, for example, data collection for an experiment, without using the network. Analysis A LogCollector outputs a stream of structured logs in standards compliant Json. These logs can be fed to a stack like the ELK, processed with third-party tools like Matlab or Excel, or processed programmatically on platforms such as Python. See the Analysis section for examples of how to process the logs.","title":"Introduction"},{"location":"eventlogging/#introduction","text":"Networked VR applications require different types of logging, such as: Debug Logs Experiment Logs Network Traces Refers to logging expected and exceptional events that occur during a regular session. The purpose is post-hoc debugging of high-level application code. Refers to logging application-specific data, such as measurements or questionnaire responses for an experiment. Refers to captures of network traffic to investigate reproducible low-level netcode bugs. (1) & (2) are handled by Ubiq's Event Logging system. (3) has distinct performance implications, so is handled seperately.","title":"Introduction"},{"location":"eventlogging/#use-case","text":"The Event Logging System is for collecting low or medium frequency events from multiple peers. The Event Logging system can log both Ubiq and third-party events, which can then be extracted and analysed. Events are discrete, but otherwise have very few restrictions. It is up to the user to ensure that event logging in their application doesn't negatively affect performance.","title":"Use Case"},{"location":"eventlogging/#overview","text":"Events are generated by EventLogger instances placed throughout the application. Events generated by these components are passed to a LogManager instance. The LogManager forwards all events in an application to a LogCollector , and the LogCollector writes them to disk (or database, or other endpoint). LogManager and LogCollector can be on the same machine or separated by the network.","title":"Overview"},{"location":"eventlogging/#eventlogger","text":"EventLogger instances are lightweight objects that the application uses to log events. Calls to an EventLogger are expected to be placed throughout the system persistently, rather than gated with pre-processor defines. The most common types of event logger are the ContextEventLogger , which is designed to work with Components that have a NetworkContext , and the UserEventLogger , designed for logging measurements in experiments. public class VoipPeerConnectionManager : MonoBehaviour, INetworkComponent { private EventLogger logger; private void Start() { context = NetworkScene.Register(this); logger = new ContextEventLogger(context); } public void ProcessMessage(ReferenceCountedSceneGraphMessage message) { var msg = JsonUtility.FromJson<Message>(message.ToString()); switch (msg.type) { case \"RequestPeerConnection\": logger.Log(\"CreatePeerConnectionForRequest\", msg.objectid); break; } } } The snippet above demonstrates the creation and use of a ContextEventLogger . The VoipPeerConnectionManager declares the logger and initialises it with a ContextEventLogger once a context has been created. The Log method can then be called to log the receipt of a specific message. EventLogger instances attach to a single LogManager . Event logger constructors find the closest LogManager automatically. EventLogger methods can be safely called from outside the Unity main thread. They should not be called from outside CLR threads however. EventLogger instances are designed to have zero overhead when logs are not actually written. The Log method has many overloads to avoid boxing, and serialisation only runs when logging is on. Logs are only written when there is a listening LogManager in the scene. It is encouraged to make as many EventLogger instances as needed. Individual event loggers are simple, with few options. Use multiple EventLogger instances within a class to get fine-grained control over logging, for example different log levels.","title":"EventLogger"},{"location":"eventlogging/#user-and-application-events","text":"An EventLogger can tag events as Application or User events. The LogManager can forward either or both types of event. The LogCollector will have different endpoints for different tags. In the case of the default LogCollector , events will be written to different files. The purpose is to make using the Event Logging System for experiments easier, by acknowledging that for such applications, generating log outputs are the primary purpose, and that such outputs are distinct from those used to debug and develop it. ComponentEventLogger and ContextEventLogger have their type set to Application by default, whereas the UserEventLogger has its type set to User . The type for all EventLogger instances can be overridden at any time. All Ubiq events are of the type Application . The distinction between Application and User is not between Ubiq code and user code, but the purpose of the log; it is expected user applications will output both types, depending on their purpose.","title":"User and Application Events"},{"location":"eventlogging/#logmanager","text":"When a LogManager is placed in a scene, it will recieve events from nearby event loggers. By default the LogManager will cache events up to a limit (50 Mb worth), dropping older events as new ones are receieved. LogManager can also be set to store an infinite number of events, which may be desirable for experiments if the limit may be reached before a LogCollector is created. There are no bounds on how much memory it may consume in this mode however, up to and including triggering out of memory exceptions for the whole application. When instructed, the LogManager will forward these events and any new ones to a LogCollector , the Component that actually writes the logs to an endpoint such as the disk, or database. Each Peer must have at least one LogManager to emit log events; event loggers cannot communicate over the network themselves. Only one LogCollector is needed between all Peers, though multiple collectors may be present (in which case all will receive all events). At least one LogCollector must be present in the network for logs to be written; a LogManager can cache logs but it cannot write them anywhere. Filtering of User and Application events is done at the LogManager . If a LogManager does not listen for a type of event, it is the equivalent of not having a LogManager in the scene for an EventLogger of that type.","title":"LogManager"},{"location":"eventlogging/#logcollector","text":"LogCollector instances receive events from LogManager instances and write them to an appropriate location. LogCollector instances can also control LogManager instances remotely - for example, starting and stopping the transmission of events. A single LogCollector receives all event types; filtering can only occur at the LogManager . The current implementation of the LogCollector writes events with different types to different files in the Persistent Data folder of whatever platform it is running on. Events are written as Json (Utf8 strings). The files themselves are Json compliant, with events being placed in a top-level Json Array .","title":"LogCollector"},{"location":"eventlogging/#local-log-collection","text":"LogCollector instances will automatically recieve events sent over the network, but will also receive events from LogManager instances on the same peer, even without a network connection. LogCollector instances will find all LogManager instances at the local Peer and register them on start-up. If a LogManager is instantiated in the Root of the scene, it will find all LogManager instances in the scene. If it is instantiated in a branch of the scene, it will find all LogManager instances within that branch. This allows logging events entirely on one machine, for example, data collection for an experiment, without using the network.","title":"Local Log Collection"},{"location":"eventlogging/#analysis","text":"A LogCollector outputs a stream of structured logs in standards compliant Json. These logs can be fed to a stack like the ELK, processed with third-party tools like Matlab or Excel, or processed programmatically on platforms such as Python. See the Analysis section for examples of how to process the logs.","title":"Analysis"},{"location":"eventloggingexperimentquestionnaire/","text":"Questionnaire The Questionnaire Sample (Samples/Single/Questionnaire) shows how the Event Logging System may be used to collect questionnaire responses. This scene contains a panel with an example Component, Questionnaire attached to it. The Component iterates over all Slider instances under its GameObject , and uses a UserEventLogger to write their values when the user clicks Done . public class Questionnaire : MonoBehaviour { EventLogger results; // Start is called before the first frame update void Start() { results = new UserEventLogger(this); } public void Done() { foreach (var item in GetComponentsInChildren<Slider>()) { results.Log(\"Answer\", item.name, item.value); } } } The scene contains a script LogCreatorCollector that creates a LogCollector if the Scene is running in the Editor, as an experimentor may do. The Questionnaire can be completed locally. Alternatively, the scene can be run remotely, and the experimentor in the Editor can click Start Collection on the LogCollector to recieve the Questionnaire results. The experimentor can click Start Collection before or after the questionnaire has been completed, and the participant can complete the Questionnaire before or after joining the room. In all cases the results will be receieved correctly. Sample Output Below is the resulting User log file from an application built with the Questionnaire scene. [ {\"ticks\":637599760103005990,\"event\":\"Answer\",\"arg1\":\"Slider 1\",\"arg2\":0.7987003}, {\"ticks\":637599760103292320,\"event\":\"Answer\",\"arg1\":\"Slider 2\",\"arg2\":0.28863412}, {\"ticks\":637599760103293850,\"event\":\"Answer\",\"arg1\":\"Slider 3\",\"arg2\":0.7020102} ] The Questionnaire was filled in on an Oculus Quest, after joining the same room as a user running the same scene in the Unity Editor. As soon as the Questionnaire was completed, the Unity Editor user could find the User log by clicking the Open Folder button of the LogCollector Component in the Editor. Since no filters were set up on the LogManager , an Application log for the session is also created in the same folder. [ {\"ticks\":637599759770020997,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"a9ac9ce0-5386f227\",\"arg2\":\"DESKTOP-F1J0MRR\",\"arg3\":\"System Product Name (ASUS)\",\"arg4\":\"f73fe01b1e21031d49274a1491d1d6b5714c92e9\"}, {\"ticks\":637599760035593770,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"a9ac9ce0-5386f227\",\"objectid\":\"a9ac9ce0-5386f227\",\"componentid\":50,\"event\":\"CreatePeerConnectionForRequest\",\"arg1\":\"ed04a433-51c8dee5\"}, {\"ticks\":637599759801422540,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"76dc754d-8faf26a5\",\"arg2\":\"Oculus Quest\",\"arg3\":\"Oculus Quest\",\"arg4\":\"b8db4746286db62ecad4c6fa13f17ab6\"}, {\"ticks\":637599760026272940,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"76dc754d-8faf26a5\",\"objectid\":\"76dc754d-8faf26a5\",\"componentid\":50,\"event\":\"CreatePeerConnectionForPeer\",\"arg1\":\"ed04a433-51c8dee5\",\"arg2\":\"a9ac9ce0-5386f227\"}, {\"ticks\":637599760026660240,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"76dc754d-8faf26a5\",\"objectid\":\"76dc754d-8faf26a5\",\"componentid\":50,\"event\":\"RequestPeerConnection\",\"arg1\":\"ed04a433-51c8dee5\",\"arg2\":\"a9ac9ce0-5386f227\"} ]","title":"Questionnaire"},{"location":"eventloggingexperimentquestionnaire/#questionnaire","text":"The Questionnaire Sample (Samples/Single/Questionnaire) shows how the Event Logging System may be used to collect questionnaire responses. This scene contains a panel with an example Component, Questionnaire attached to it. The Component iterates over all Slider instances under its GameObject , and uses a UserEventLogger to write their values when the user clicks Done . public class Questionnaire : MonoBehaviour { EventLogger results; // Start is called before the first frame update void Start() { results = new UserEventLogger(this); } public void Done() { foreach (var item in GetComponentsInChildren<Slider>()) { results.Log(\"Answer\", item.name, item.value); } } } The scene contains a script LogCreatorCollector that creates a LogCollector if the Scene is running in the Editor, as an experimentor may do. The Questionnaire can be completed locally. Alternatively, the scene can be run remotely, and the experimentor in the Editor can click Start Collection on the LogCollector to recieve the Questionnaire results. The experimentor can click Start Collection before or after the questionnaire has been completed, and the participant can complete the Questionnaire before or after joining the room. In all cases the results will be receieved correctly.","title":"Questionnaire"},{"location":"eventloggingexperimentquestionnaire/#sample-output","text":"Below is the resulting User log file from an application built with the Questionnaire scene. [ {\"ticks\":637599760103005990,\"event\":\"Answer\",\"arg1\":\"Slider 1\",\"arg2\":0.7987003}, {\"ticks\":637599760103292320,\"event\":\"Answer\",\"arg1\":\"Slider 2\",\"arg2\":0.28863412}, {\"ticks\":637599760103293850,\"event\":\"Answer\",\"arg1\":\"Slider 3\",\"arg2\":0.7020102} ] The Questionnaire was filled in on an Oculus Quest, after joining the same room as a user running the same scene in the Unity Editor. As soon as the Questionnaire was completed, the Unity Editor user could find the User log by clicking the Open Folder button of the LogCollector Component in the Editor. Since no filters were set up on the LogManager , an Application log for the session is also created in the same folder. [ {\"ticks\":637599759770020997,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"a9ac9ce0-5386f227\",\"arg2\":\"DESKTOP-F1J0MRR\",\"arg3\":\"System Product Name (ASUS)\",\"arg4\":\"f73fe01b1e21031d49274a1491d1d6b5714c92e9\"}, {\"ticks\":637599760035593770,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"a9ac9ce0-5386f227\",\"objectid\":\"a9ac9ce0-5386f227\",\"componentid\":50,\"event\":\"CreatePeerConnectionForRequest\",\"arg1\":\"ed04a433-51c8dee5\"}, {\"ticks\":637599759801422540,\"type\":\"Ubiq.Messaging.NetworkScene\",\"event\":\"Awake\",\"arg1\":\"76dc754d-8faf26a5\",\"arg2\":\"Oculus Quest\",\"arg3\":\"Oculus Quest\",\"arg4\":\"b8db4746286db62ecad4c6fa13f17ab6\"}, {\"ticks\":637599760026272940,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"76dc754d-8faf26a5\",\"objectid\":\"76dc754d-8faf26a5\",\"componentid\":50,\"event\":\"CreatePeerConnectionForPeer\",\"arg1\":\"ed04a433-51c8dee5\",\"arg2\":\"a9ac9ce0-5386f227\"}, {\"ticks\":637599760026660240,\"type\":\"Ubiq.Voip.VoipPeerConnectionManager\",\"sceneid\":\"76dc754d-8faf26a5\",\"objectid\":\"76dc754d-8faf26a5\",\"componentid\":50,\"event\":\"RequestPeerConnection\",\"arg1\":\"ed04a433-51c8dee5\",\"arg2\":\"a9ac9ce0-5386f227\"} ]","title":"Sample Output"},{"location":"eventlogginggettingstarted/","text":"Logging Ubiq has the ability to record, forward and store logs or events. Ubiq itself generates logs, and custom components can create them too. For example, the logging system could be used to record the answers to a questionnaire, or the direction of a user's gaze, and forward them to an experimentor. This guide shows how to set up and log some simple data in the Hello World scene. Log Flow Log events (such as answering a question) are generated by Event Loggers with a simple call, e.g. logger.Log(\"MyEvent\") . These events are received by the Log Manager. Log Managers can send these events over the network to a Log Collector in the same Room. LogManager and LogCollector are Components beloning to a NetworkScene . There can be many Event Loggers in an application. There should be one LogManager for each NetworkScene . There should be at most one active LogCollector in a Room. The LogCollector can be on any Peer. For example, it could be on the computer of an experimentor. Creating a Questionnaire Button Log events can come from any source. In this guide, they will be generated when a user presses a button. Create a new Button in the scene. Below, a new GameObject was added to the Main Menu . Create a new script, ButtonLogger , and add it to the Button as well. The script for ButtonLogger is below. using Ubiq.Logging; using UnityEngine; using UnityEngine.UI; public class ButtonLogger : MonoBehaviour { UserEventLogger events; // Start is called before the first frame update void Start() { events = new UserEventLogger(this); GetComponent<Button>().onClick.AddListener(OnButtonClicked); } void OnButtonClicked() { events.Log(\"Button Pressed\"); } } First, a UserEventLogger is declared. This is the object that will be used to emit log events. It is declared in the class but initialiesd in Start() . This is because it has to find the local Log Manager to communicate with, which can't be done until the scene initialisation begins. Event Loggers There are two types of event: User and Application . Application events are meant to record how the application itself is working (application code), while User events (user code) are created by the appliation, but for another purpose, e.g. to record study data or usage metrics. Any code can create either type of event. The difference is only in how they are intended to be used. (The two types of event end up in different log files.) The Event Logger created in the ButtonLogger script will generate User events. Log Manager The default NetworkScene Prefab already contains a LogManager, so there is no need to add this. Second, a callback is registered with the Button's OnClick event. Finally, when this is raised by the user clicking the button, a log event (\"Button Pressed\") is emitted. Start the Scene and look at the Log Manager in the Inspector. As the Button is clicked the memory usage of the manager will increase, indicating that the Button is generating events. Log Collector The events will remain in the LogManager until they are retrieved. This is done with a LogCollector . Add a LogCollector underneath the LogManager . Start the Scene and click the button a few times. Then click Start Collection . The Entries count will increase, and opening the log folder will reveal a User log, with a number of Button Pressed events. [{\"ticks\":637684411200317851,\"event\":\"Button Pressed\"}, {\"ticks\":637684411201982783,\"event\":\"Button Pressed\"}, {\"ticks\":637684411203585606,\"event\":\"Button Pressed\"}, {\"ticks\":637684411205105584,\"event\":\"Button Pressed\"}, {\"ticks\":637684411206535592,\"event\":\"Button Pressed\"}, {\"ticks\":637684411208055613,\"event\":\"Button Pressed\"}, {\"ticks\":637684411209415586,\"event\":\"Button Pressed\"}, {\"ticks\":637684411211005613,\"event\":\"Button Pressed\"}, {\"ticks\":637684411212455585,\"event\":\"Button Pressed\"} Logging Arguments The EventLogger::Log() method can take a number of arguments in addition to the event name. Add a new member to the ButtonLogger, AnswerName , and pass it in as an argument. public string Answer; void OnButtonClicked() { events.Log(\"Button Pressed\", Answer); } The value of Answer can be set up in the inspector. Duplicate the Button and set two different values of Answer for each. Now, when looking at the log after pressing the buttons it will show the value of Answer as well. [{\"ticks\":637684423675170428,\"event\":\"Button Pressed\",\"arg1\":\"Yes\"}, {\"ticks\":637684423676660455,\"event\":\"Button Pressed\",\"arg1\":\"Yes\"}, {\"ticks\":637684423680253262,\"event\":\"Button Pressed\",\"arg1\":\"No\"}, {\"ticks\":637684423681853281,\"event\":\"Button Pressed\",\"arg1\":\"No\"} Practically any variable that can be turned into a string can be logged this way. Collecting from a Distributed Experiment So far the LogCollector has just collected from the local LogManager . Create a Build of the Hello World application and run it, then press the buttons a few times. Note that so far, the application has not even joined a room. This is OK because the LogManagaer will hold all logs until they are requested. Next, press Play to load the Hello World Scene in the Editor. Now have both Peers join the same room (new or old, in any order). When both have joined, the Avatars of the other Peer should be visible in each. In the Editor, navigate to the LogCollector and click on Start Collection in the Inspector. The Entries count will increase, and a User Log file will appear in the default Logs Folder, containing the answers entered in the Standalone Build. Considerations To find out more about the logging, see the Logging section in the Advanced topics. Log events can be generated from user actions, but also other external events, or at a regular frequency (e.g. to log the Transform of dynamic objects) In this example, the LogCollector was in the scene that went into the Standalone Build, but this is not necessary. Only one Peer needs a LogCollector to collect logs from all Peers. The LogCollector does not have to be next to a LogManager . The LogCollector does not even need a LogManager in the NetworkScene . If the collection is not started, a LogCollector has no effect. Log Collectors can even be added at runtime. To see this, re-create the Standalone Build, but with the LogCollector removed. Follow the steps above, but when in the Editor after joining the Room, add a new LogCollector at runtime, then click Start Collection . The logs will be collected exactly as before. Collection can also be started programmatically, in addition to clicking Start Collection . This allows experiment code to start collection other ways, including in Standalone builds.","title":"Logging"},{"location":"eventlogginggettingstarted/#logging","text":"Ubiq has the ability to record, forward and store logs or events. Ubiq itself generates logs, and custom components can create them too. For example, the logging system could be used to record the answers to a questionnaire, or the direction of a user's gaze, and forward them to an experimentor. This guide shows how to set up and log some simple data in the Hello World scene.","title":"Logging"},{"location":"eventlogginggettingstarted/#log-flow","text":"Log events (such as answering a question) are generated by Event Loggers with a simple call, e.g. logger.Log(\"MyEvent\") . These events are received by the Log Manager. Log Managers can send these events over the network to a Log Collector in the same Room. LogManager and LogCollector are Components beloning to a NetworkScene . There can be many Event Loggers in an application. There should be one LogManager for each NetworkScene . There should be at most one active LogCollector in a Room. The LogCollector can be on any Peer. For example, it could be on the computer of an experimentor.","title":"Log Flow"},{"location":"eventlogginggettingstarted/#creating-a-questionnaire-button","text":"Log events can come from any source. In this guide, they will be generated when a user presses a button. Create a new Button in the scene. Below, a new GameObject was added to the Main Menu . Create a new script, ButtonLogger , and add it to the Button as well. The script for ButtonLogger is below. using Ubiq.Logging; using UnityEngine; using UnityEngine.UI; public class ButtonLogger : MonoBehaviour { UserEventLogger events; // Start is called before the first frame update void Start() { events = new UserEventLogger(this); GetComponent<Button>().onClick.AddListener(OnButtonClicked); } void OnButtonClicked() { events.Log(\"Button Pressed\"); } } First, a UserEventLogger is declared. This is the object that will be used to emit log events. It is declared in the class but initialiesd in Start() . This is because it has to find the local Log Manager to communicate with, which can't be done until the scene initialisation begins.","title":"Creating a Questionnaire Button"},{"location":"eventlogginggettingstarted/#event-loggers","text":"There are two types of event: User and Application . Application events are meant to record how the application itself is working (application code), while User events (user code) are created by the appliation, but for another purpose, e.g. to record study data or usage metrics. Any code can create either type of event. The difference is only in how they are intended to be used. (The two types of event end up in different log files.) The Event Logger created in the ButtonLogger script will generate User events.","title":"Event Loggers"},{"location":"eventlogginggettingstarted/#log-manager","text":"The default NetworkScene Prefab already contains a LogManager, so there is no need to add this. Second, a callback is registered with the Button's OnClick event. Finally, when this is raised by the user clicking the button, a log event (\"Button Pressed\") is emitted. Start the Scene and look at the Log Manager in the Inspector. As the Button is clicked the memory usage of the manager will increase, indicating that the Button is generating events.","title":"Log Manager"},{"location":"eventlogginggettingstarted/#log-collector","text":"The events will remain in the LogManager until they are retrieved. This is done with a LogCollector . Add a LogCollector underneath the LogManager . Start the Scene and click the button a few times. Then click Start Collection . The Entries count will increase, and opening the log folder will reveal a User log, with a number of Button Pressed events. [{\"ticks\":637684411200317851,\"event\":\"Button Pressed\"}, {\"ticks\":637684411201982783,\"event\":\"Button Pressed\"}, {\"ticks\":637684411203585606,\"event\":\"Button Pressed\"}, {\"ticks\":637684411205105584,\"event\":\"Button Pressed\"}, {\"ticks\":637684411206535592,\"event\":\"Button Pressed\"}, {\"ticks\":637684411208055613,\"event\":\"Button Pressed\"}, {\"ticks\":637684411209415586,\"event\":\"Button Pressed\"}, {\"ticks\":637684411211005613,\"event\":\"Button Pressed\"}, {\"ticks\":637684411212455585,\"event\":\"Button Pressed\"}","title":"Log Collector"},{"location":"eventlogginggettingstarted/#logging-arguments","text":"The EventLogger::Log() method can take a number of arguments in addition to the event name. Add a new member to the ButtonLogger, AnswerName , and pass it in as an argument. public string Answer; void OnButtonClicked() { events.Log(\"Button Pressed\", Answer); } The value of Answer can be set up in the inspector. Duplicate the Button and set two different values of Answer for each. Now, when looking at the log after pressing the buttons it will show the value of Answer as well. [{\"ticks\":637684423675170428,\"event\":\"Button Pressed\",\"arg1\":\"Yes\"}, {\"ticks\":637684423676660455,\"event\":\"Button Pressed\",\"arg1\":\"Yes\"}, {\"ticks\":637684423680253262,\"event\":\"Button Pressed\",\"arg1\":\"No\"}, {\"ticks\":637684423681853281,\"event\":\"Button Pressed\",\"arg1\":\"No\"} Practically any variable that can be turned into a string can be logged this way.","title":"Logging Arguments"},{"location":"eventlogginggettingstarted/#collecting-from-a-distributed-experiment","text":"So far the LogCollector has just collected from the local LogManager . Create a Build of the Hello World application and run it, then press the buttons a few times. Note that so far, the application has not even joined a room. This is OK because the LogManagaer will hold all logs until they are requested. Next, press Play to load the Hello World Scene in the Editor. Now have both Peers join the same room (new or old, in any order). When both have joined, the Avatars of the other Peer should be visible in each. In the Editor, navigate to the LogCollector and click on Start Collection in the Inspector. The Entries count will increase, and a User Log file will appear in the default Logs Folder, containing the answers entered in the Standalone Build.","title":"Collecting from a Distributed Experiment"},{"location":"eventlogginggettingstarted/#considerations","text":"To find out more about the logging, see the Logging section in the Advanced topics. Log events can be generated from user actions, but also other external events, or at a regular frequency (e.g. to log the Transform of dynamic objects) In this example, the LogCollector was in the scene that went into the Standalone Build, but this is not necessary. Only one Peer needs a LogCollector to collect logs from all Peers. The LogCollector does not have to be next to a LogManager . The LogCollector does not even need a LogManager in the NetworkScene . If the collection is not started, a LogCollector has no effect. Log Collectors can even be added at runtime. To see this, re-create the Standalone Build, but with the LogCollector removed. Follow the steps above, but when in the Editor after joining the Room, add a new LogCollector at runtime, then click Start Collection . The logs will be collected exactly as before. Collection can also be started programmatically, in addition to clicking Start Collection . This allows experiment code to start collection other ways, including in Standalone builds.","title":"Considerations"},{"location":"eventlogserialisation/","text":"Serialiser The logging functionality uses a custom Json serialiser that facilitates building Json objects across multiple function calls. This is based on neuecc's Utf8Json , but with modifications to track memory usage and remove code generation requirements. The Utf8Json serialiser is in the Ubiq.Logging.Utf8Json namspace. It is not recommended to use the serialiser for purposes other than logging; import an unmodified version of the library separately instead. Formatters Libraries such as Utf8Json typically have methods that serialise and deseralise specific types by sequentially reading and writing tokens to and from streams. (In this case, the tokes are read and written using the JsonReader and JsonWriter structures.) Utf8Json finds the appropriate method to use using FormatterResovler classes. These classes return a cached Formatter<T> class, which is an object with two methods to read and write objects of type T as Json. The included version of Utf8Json includes formatters for a number of known types, including all the basic primitives, and enums. Enums are serialised as names. Code Generation To serialise types that do not have an explicit formatter defined, libraries such as Utf8Json usually build serialisation methods at runtime using code generation. This is not supported on platforms that use IL2CPP however. To avoid code generation, unknown types are serialised by the Unity JsonUtility and embedded as objects. Resolvers and Formatters When a type is serialised, Utf8Json will use the DefaultResolver to find a formatter. The DefaultResolver is defined in the JsonSerializer class as a static member and returns a StandardResolver , a type of composite resolver. This resolver will search each resolver registered to it in turn, and return the first Formatter that matches the type. The StandardResolver includes formatters for the built-in types, and the dynamic formatter fallback. Caching Utf8Json makes common use of the following design pattern. public IJsonFormatter<T> GetFormatter<T>() { return FormatterCache<T>.formatter; } static class FormatterCache<T> { public static readonly IJsonFormatter<T> formatter; static FormatterCache() { formatter = (IJsonFormatter<T>)BuiltinResolverGetFormatterHelper.GetFormatter(typeof(T)); } } This snippet leverages the behaviour of generics in C# to replace formatter references in code, without using code generation. In C#, when a generic type is first constructed , the runtime will produce the concrete type and substitute it in the appropriate locations in the MSIL. The static constructor is called before the formatter is referenced for the first time. That is, the generic FormatterCache type is replaced in the MSIL and the formatter member it returns is resolved on demand (when the FormatterCache<T> is first constructed). Memory Management The Utf8Json namespace manages its own global memory pools to minimise GC allocations. It does not track memory usage directly however. Instead, LogManager instances track how many bytes of pooled memory they have in their queues at any time, and use this to control whether new events are buffered or dropped. Memory is rented from the pool on demand by JsonWriter objects created by EventLogger instances. Outstanding memory is returned to the pool when a JsonWriter is disposed. JsonWriters are disposed by the LogManager they are fed to, either after being copied for transmission or discarded when the buffer reaches capacity. EventLogger instances only create JsonWriters if a LogManager has been registered to recieve (and dispose of) the completed object.","title":"Serialisation and Memory"},{"location":"eventlogserialisation/#serialiser","text":"The logging functionality uses a custom Json serialiser that facilitates building Json objects across multiple function calls. This is based on neuecc's Utf8Json , but with modifications to track memory usage and remove code generation requirements. The Utf8Json serialiser is in the Ubiq.Logging.Utf8Json namspace. It is not recommended to use the serialiser for purposes other than logging; import an unmodified version of the library separately instead.","title":"Serialiser"},{"location":"eventlogserialisation/#formatters","text":"Libraries such as Utf8Json typically have methods that serialise and deseralise specific types by sequentially reading and writing tokens to and from streams. (In this case, the tokes are read and written using the JsonReader and JsonWriter structures.) Utf8Json finds the appropriate method to use using FormatterResovler classes. These classes return a cached Formatter<T> class, which is an object with two methods to read and write objects of type T as Json. The included version of Utf8Json includes formatters for a number of known types, including all the basic primitives, and enums. Enums are serialised as names.","title":"Formatters"},{"location":"eventlogserialisation/#code-generation","text":"To serialise types that do not have an explicit formatter defined, libraries such as Utf8Json usually build serialisation methods at runtime using code generation. This is not supported on platforms that use IL2CPP however. To avoid code generation, unknown types are serialised by the Unity JsonUtility and embedded as objects.","title":"Code Generation"},{"location":"eventlogserialisation/#resolvers-and-formatters","text":"When a type is serialised, Utf8Json will use the DefaultResolver to find a formatter. The DefaultResolver is defined in the JsonSerializer class as a static member and returns a StandardResolver , a type of composite resolver. This resolver will search each resolver registered to it in turn, and return the first Formatter that matches the type. The StandardResolver includes formatters for the built-in types, and the dynamic formatter fallback.","title":"Resolvers and Formatters"},{"location":"eventlogserialisation/#caching","text":"Utf8Json makes common use of the following design pattern. public IJsonFormatter<T> GetFormatter<T>() { return FormatterCache<T>.formatter; } static class FormatterCache<T> { public static readonly IJsonFormatter<T> formatter; static FormatterCache() { formatter = (IJsonFormatter<T>)BuiltinResolverGetFormatterHelper.GetFormatter(typeof(T)); } } This snippet leverages the behaviour of generics in C# to replace formatter references in code, without using code generation. In C#, when a generic type is first constructed , the runtime will produce the concrete type and substitute it in the appropriate locations in the MSIL. The static constructor is called before the formatter is referenced for the first time. That is, the generic FormatterCache type is replaced in the MSIL and the formatter member it returns is resolved on demand (when the FormatterCache<T> is first constructed).","title":"Caching"},{"location":"eventlogserialisation/#memory-management","text":"The Utf8Json namespace manages its own global memory pools to minimise GC allocations. It does not track memory usage directly however. Instead, LogManager instances track how many bytes of pooled memory they have in their queues at any time, and use this to control whether new events are buffered or dropped. Memory is rented from the pool on demand by JsonWriter objects created by EventLogger instances. Outstanding memory is returned to the pool when a JsonWriter is disposed. JsonWriters are disposed by the LogManager they are fed to, either after being copied for transmission or discarded when the buffer reaches capacity. EventLogger instances only create JsonWriters if a LogManager has been registered to recieve (and dispose of) the completed object.","title":"Memory Management"},{"location":"generatinguniqueids/","text":"Unique Ids The main considerations of Object Ids are the practices for generating UUIds, collision probabilities and bit sizes. Collision Probability Each client must be able to generate new Ids independently, to avoid dependencies on a server in peer-to-peer situations, and to avoid introducing deadlocks with the Unity programming model (such as needing a server to respond before all Start() calls can finish). The probability of collisions between two independently well-generated identifiers is the Birthday Problem . The probability of a collision is given by, On regular desktops, it is not possible to compute this for the typical numbers involved due to floating point quantisation. However there are approximations, such as the following which will work in Matlab, p = 1 - exp(-(n^2)/(2*(2^b))) As the figure below shows, the probability of collisions depends on the number of objects in the scenario n , as well as the identifier length b (in bits). In Ubiq, the \"scenario\" is typically a room. There are no rules defining acceptable chances of collisions. For example, OAuth 2 specifies a probability of less than 10e-160 , which is not achievable even by 128-bit UUIDs. In the case of a typical Ubiq room, which due to voice chat limitations can support approximately 25 users, a 32 bit value would probably be adequate. The concept of a Room in Ubiq can change depending on how it is used however, so Ubiq tries to avoid making assumptions about the potential collision space. If rooms were considered to be floating regions, for example, then the number of potential users could be much higher. It is challenging to grasp levels of chance at these scales. The table below by Jeff Preshing presents collision probabilities with some more intuitive context. (The numer of hash values below is the number of Objects between all users that could potentially connect in a Ubiq scenario, be that a room, set of rooms, a server, shard etc.) Generating Random Identifiers The collision probabilities above are only correct if identifiers are well-generated. RFC 4122 descibes algorithms to generate 128-bit UUIDs. UUIDs are standardised identifiers on many network services. They are very popular as they can be independently generated quickly, while guaranteeing uniqueness and being amenable to storing, sorting and hashing. UUIDs can guarantee uniqueness beyond the probabilities discussed above because some versions include the use of MAC addresses, which are centrally registered (by the network card manufacturer) and which act as a \"pre-shared secret\". RFC 4122 also presents an algorithm for version 4 which is based purely on random numbers. RFC 1750 discusses random numbers in more detail. Acquiring truly random numbers for identifier generation is challenging, as common computer systems rarely have APIs to access sources of truly random numbers. Most systems use deterministic generators of some kind, initialised with a seed. If there are dependencies between different sections of random number sequences, or covariances in the seed between peers, this will change the probability of collisions. To make a good identifier, best practice is to use as many data sources as possible, with a strong mixing function. A strong mixer is one where each output bit is a complex, and different, function of all the input bits. The example given in RFC 4122 is to gather data sources into a buffer and use a message digest function such as SHA-1. Identifiers and Bandwidth A motivation for minimising id size is to reduce overhead. In a packet sending a Vector3 a 16 byte (a 128-bit UUID) overhead for the Id would have an overhead of 133% without even the Component Id. Though, on modern networks even a large relative overheads may not be problems so long as the total packet size is low. IPV6, for example, has a 40 byte header alone. That is, reducing bandwidth by reducing identifier size is unlikely to be an optimal methodology. It should be expected that Ubiq header sizes increase over time, rather than decrease. Since Ubiq is based on a set of point-to-point connections, future works could consider techniques such as asymmetrical per-connection aliases to optimise bandwidth. Object Ids in Ubiq Size Currently, Object Ids are represented by 64 bit numbers. This is because the collision probability for this length is very low for scenarios anticipated by Ubiq in the near future, but it is still easy to handle; 32 bit is too small, while 128 bit would require explicit serialisation/deserialisation, hashing and equality comparisons. 64 bit numbers can be stored in a long and nowadays even mobile platforms use 64 bit processors. Unique Ids in Unity Unity provides a number of data sources for hashing inside the Application and SystemInfo classes, however these are not accessible in class constructors. Therefore the .NET System.Environment, System.DateTime and System.Random classes are used. References Jesus, P., Baquero, C., & Almeida, P. (2006). ID Generation in Mobile Environments. 1\u20134. http://hdl.handle.net/1822/36065 https://neilmadden.blog/2018/08/30/moving-away-from-uuids/ https://preshing.com/20110504/hash-collision-probabilities/ https://tools.ietf.org/html/rfc4122","title":"Generating Unique Ids"},{"location":"generatinguniqueids/#unique-ids","text":"The main considerations of Object Ids are the practices for generating UUIds, collision probabilities and bit sizes.","title":"Unique Ids"},{"location":"generatinguniqueids/#collision-probability","text":"Each client must be able to generate new Ids independently, to avoid dependencies on a server in peer-to-peer situations, and to avoid introducing deadlocks with the Unity programming model (such as needing a server to respond before all Start() calls can finish). The probability of collisions between two independently well-generated identifiers is the Birthday Problem . The probability of a collision is given by, On regular desktops, it is not possible to compute this for the typical numbers involved due to floating point quantisation. However there are approximations, such as the following which will work in Matlab, p = 1 - exp(-(n^2)/(2*(2^b))) As the figure below shows, the probability of collisions depends on the number of objects in the scenario n , as well as the identifier length b (in bits). In Ubiq, the \"scenario\" is typically a room. There are no rules defining acceptable chances of collisions. For example, OAuth 2 specifies a probability of less than 10e-160 , which is not achievable even by 128-bit UUIDs. In the case of a typical Ubiq room, which due to voice chat limitations can support approximately 25 users, a 32 bit value would probably be adequate. The concept of a Room in Ubiq can change depending on how it is used however, so Ubiq tries to avoid making assumptions about the potential collision space. If rooms were considered to be floating regions, for example, then the number of potential users could be much higher. It is challenging to grasp levels of chance at these scales. The table below by Jeff Preshing presents collision probabilities with some more intuitive context. (The numer of hash values below is the number of Objects between all users that could potentially connect in a Ubiq scenario, be that a room, set of rooms, a server, shard etc.)","title":"Collision Probability"},{"location":"generatinguniqueids/#generating-random-identifiers","text":"The collision probabilities above are only correct if identifiers are well-generated. RFC 4122 descibes algorithms to generate 128-bit UUIDs. UUIDs are standardised identifiers on many network services. They are very popular as they can be independently generated quickly, while guaranteeing uniqueness and being amenable to storing, sorting and hashing. UUIDs can guarantee uniqueness beyond the probabilities discussed above because some versions include the use of MAC addresses, which are centrally registered (by the network card manufacturer) and which act as a \"pre-shared secret\". RFC 4122 also presents an algorithm for version 4 which is based purely on random numbers. RFC 1750 discusses random numbers in more detail. Acquiring truly random numbers for identifier generation is challenging, as common computer systems rarely have APIs to access sources of truly random numbers. Most systems use deterministic generators of some kind, initialised with a seed. If there are dependencies between different sections of random number sequences, or covariances in the seed between peers, this will change the probability of collisions. To make a good identifier, best practice is to use as many data sources as possible, with a strong mixing function. A strong mixer is one where each output bit is a complex, and different, function of all the input bits. The example given in RFC 4122 is to gather data sources into a buffer and use a message digest function such as SHA-1.","title":"Generating Random Identifiers"},{"location":"generatinguniqueids/#identifiers-and-bandwidth","text":"A motivation for minimising id size is to reduce overhead. In a packet sending a Vector3 a 16 byte (a 128-bit UUID) overhead for the Id would have an overhead of 133% without even the Component Id. Though, on modern networks even a large relative overheads may not be problems so long as the total packet size is low. IPV6, for example, has a 40 byte header alone. That is, reducing bandwidth by reducing identifier size is unlikely to be an optimal methodology. It should be expected that Ubiq header sizes increase over time, rather than decrease. Since Ubiq is based on a set of point-to-point connections, future works could consider techniques such as asymmetrical per-connection aliases to optimise bandwidth.","title":"Identifiers and Bandwidth"},{"location":"generatinguniqueids/#object-ids-in-ubiq","text":"","title":"Object Ids in Ubiq"},{"location":"generatinguniqueids/#size","text":"Currently, Object Ids are represented by 64 bit numbers. This is because the collision probability for this length is very low for scenarios anticipated by Ubiq in the near future, but it is still easy to handle; 32 bit is too small, while 128 bit would require explicit serialisation/deserialisation, hashing and equality comparisons. 64 bit numbers can be stored in a long and nowadays even mobile platforms use 64 bit processors.","title":"Size"},{"location":"generatinguniqueids/#unique-ids-in-unity","text":"Unity provides a number of data sources for hashing inside the Application and SystemInfo classes, however these are not accessible in class constructors. Therefore the .NET System.Environment, System.DateTime and System.Random classes are used.","title":"Unique Ids in Unity"},{"location":"generatinguniqueids/#references","text":"Jesus, P., Baquero, C., & Almeida, P. (2006). ID Generation in Mobile Environments. 1\u20134. http://hdl.handle.net/1822/36065 https://neilmadden.blog/2018/08/30/moving-away-from-uuids/ https://preshing.com/20110504/hash-collision-probabilities/ https://tools.ietf.org/html/rfc4122","title":"References"},{"location":"gettingubiq/","text":"Getting Ubiq Ubiq can be downloaded from the UCL VR Github: https://github.com/UCL-VR/ubiq WebRTC Ubiq relies on WebRTC for voice and video chat. The repository includes binaries for Windows, Linux, Android and MacOS, so you do not need to download anything else. The project to build the binaries though can also be found on the UCL VR Github.","title":"Getting Ubiq"},{"location":"gettingubiq/#getting-ubiq","text":"Ubiq can be downloaded from the UCL VR Github: https://github.com/UCL-VR/ubiq","title":"Getting Ubiq"},{"location":"gettingubiq/#webrtc","text":"Ubiq relies on WebRTC for voice and video chat. The repository includes binaries for Windows, Linux, Android and MacOS, so you do not need to download anything else. The project to build the binaries though can also be found on the UCL VR Github.","title":"WebRTC"},{"location":"leavingandjoiningrooms/","text":"Leaving and Joining When a RoomClient starts it is automatically a member of an empty, unidentified, room. A RoomClient can create a new room or join an existing one at any time. Joining or leaving a room involes a room change . Changing the room is the same whether the client is going to or from an empty room, or between non-empty rooms. When the room changes RoomClient will emit a number of events, in order: OnPeerRemoved for any peers that go out of scope OnPeerAdded for any peers that come into scope OnPeerUpdated for any peers that are in scope but whose properties have changed OnJoinedRoom with the new room OnRoomUpdated with the new room Whether a Peer is in scope means whether or not it is available to current Peer. If two Peers moved to another room at the same time, they would remain in scope because the Peers themselves remain in the same rooms, even though that room has changed. On the other hand, if a Peer joins a different Room, it will go out of scope, as it is no longer in the same room, even though it may still be connected to the server. The purpose of rooms is to facilitate message exchanging between specific sets of peers. Most Components should use the Peer events to create, destroy and update objects. The Room events are typically used when code needs to control room membership, for example the UI panels for joining rooms. There is no such thing as leaving a room; underneath, leaving a Room means joining a new, empty Room.","title":"Leaving and Joining"},{"location":"leavingandjoiningrooms/#leaving-and-joining","text":"When a RoomClient starts it is automatically a member of an empty, unidentified, room. A RoomClient can create a new room or join an existing one at any time. Joining or leaving a room involes a room change . Changing the room is the same whether the client is going to or from an empty room, or between non-empty rooms. When the room changes RoomClient will emit a number of events, in order: OnPeerRemoved for any peers that go out of scope OnPeerAdded for any peers that come into scope OnPeerUpdated for any peers that are in scope but whose properties have changed OnJoinedRoom with the new room OnRoomUpdated with the new room Whether a Peer is in scope means whether or not it is available to current Peer. If two Peers moved to another room at the same time, they would remain in scope because the Peers themselves remain in the same rooms, even though that room has changed. On the other hand, if a Peer joins a different Room, it will go out of scope, as it is no longer in the same room, even though it may still be connected to the server. The purpose of rooms is to facilitate message exchanging between specific sets of peers. Most Components should use the Peer events to create, destroy and update objects. The Room events are typically used when code needs to control room membership, for example the UI panels for joining rooms. There is no such thing as leaving a room; underneath, leaving a Room means joining a new, empty Room.","title":"Leaving and Joining"},{"location":"localloopback/","text":"Testing Networked Objects A local loopback scene is included in the Ubiq samples. Local loopback is helpful for testing your networked objects without needing to use any external applications. The scene contains two clients and a local server that is started when you play the scene. The scene is in the Samples/Intro folder. To get started: Click the play button. The local server is now started and you will see an avatar in one forest. At this stage, neither client is connected to the server. Expand the hierarchy for Forest 1 and click on the GameObject with the name \"NetworkScene\" within (see left image below). In the Inspector panel, click Create Room (right image below). Expand the hierarchy for Forest 2 and click the other \"NetworkScene\" GameObject. In the Inspector panel, click Refresh and you will see the room you just created. Click to join the room. Now both clients are connected to the local server and you can test your networked objects. You will notice both Forests now have avatars inside and that the avatars move in sync. There are now 4 avatars in the scene, 2 in each forest, but they share a position. This is because their positions and orientations are derived from the same player prefab.","title":"Testing with Local Loopback"},{"location":"localloopback/#testing-networked-objects","text":"A local loopback scene is included in the Ubiq samples. Local loopback is helpful for testing your networked objects without needing to use any external applications. The scene contains two clients and a local server that is started when you play the scene. The scene is in the Samples/Intro folder. To get started: Click the play button. The local server is now started and you will see an avatar in one forest. At this stage, neither client is connected to the server. Expand the hierarchy for Forest 1 and click on the GameObject with the name \"NetworkScene\" within (see left image below). In the Inspector panel, click Create Room (right image below). Expand the hierarchy for Forest 2 and click the other \"NetworkScene\" GameObject. In the Inspector panel, click Refresh and you will see the room you just created. Click to join the room. Now both clients are connected to the local server and you can test your networked objects. You will notice both Forests now have avatars inside and that the avatars move in sync. There are now 4 avatars in the scene, 2 in each forest, but they share a position. This is because their positions and orientations are derived from the same player prefab.","title":"Testing Networked Objects"},{"location":"messaging/","text":"Introduction Ubiq is built around message-based exchanges on unicast connections between peers (and servers). Messages are variable size with binary payloads. All messages passed by Ubiq have the same header. The Medium is the Message Ubiq delivers individual messages between instances of networked objects (most commonly Unity Components). How messages get from Component A to Component B is the responsiblity of the Messaging Layer, and is abstracted from the developer. Network Components only recieve messages addressed to them directly, so they can rely on knowing the type of the message by virtue of having recieved it. The expected programming model is that Components implement send and recieve functionality in the same script, which is also where the format is defined. By the time a message reaches a Component, it is received as the exact raw sequence of bytes sent by the Component's counterpart. Individual components choose the best serialisation method and transmission frequency for their use case. Scene Graph as a Bus Ubiq closely matches Unity's programming model. Since user code is placed in Components in Unity, networked objects in Ubiq are also Unity Components. Ubiq addresses have two elements: Object Id and Component Id. Object Id is analogous to the GameObject and Component Id is analgous to the Component script Type. Messages are only delivered between instances that have both the same Object Id and Component Id. This model allows complete seperation between the code that spawns and destroys Objects and the Components that make up those Objects. When an Object is created, only one identity needs to be generated and communicated, and instances of Components on different Objects don't need to disambiguate between eachother. Fan-Out at the Network Layer When a Component transmits a message, it is recieved by every other Component with the same address (Object & Component Ids). This is the case regardless of how many instances there are with the same combination. Fanning out - or multicasting - the message is done at the network layer. Individual Components don't know how many counterparts they have. Example To see how these concepts work together, consider the example of an Avatar. The avatar will have one Object Id, and two Components, one for the Skeletal Animation and one for Eye Gaze. Each Component knows only it's Component Id, which must be distinct to avoid eye gaze messages being routed to the skeletal animation and vice versa. When the Avatar is created, the Avatar Spawner generates a new unqiue identity. It instantiates a prefab locally, and communicates its identity to the other peers, so that they also may instantiate the prefab. This identity becomes the Object Id. Each peer has an instance of the prefab with the new identity. This identity represents the players avatar. When the avatar changes, e.g. its skeleton is updated with tracking information, the avatars components send messages. These are received at remote peers by the avatar's counterparts, based on them having the same Object Ids. Within the Objects, messages are delivered to the correct Component based on the Component Id. The Avatar Spawner doesn't know which Components are on the Prefab, so only has to communicate one new identity to its peers. Netiher do the Components don't need to know which Prefab they belong to, or what other Components exist on the Object. They just exchange messages with their direct counterparts.","title":"Introduction"},{"location":"messaging/#introduction","text":"Ubiq is built around message-based exchanges on unicast connections between peers (and servers). Messages are variable size with binary payloads. All messages passed by Ubiq have the same header.","title":"Introduction"},{"location":"messaging/#the-medium-is-the-message","text":"Ubiq delivers individual messages between instances of networked objects (most commonly Unity Components). How messages get from Component A to Component B is the responsiblity of the Messaging Layer, and is abstracted from the developer. Network Components only recieve messages addressed to them directly, so they can rely on knowing the type of the message by virtue of having recieved it. The expected programming model is that Components implement send and recieve functionality in the same script, which is also where the format is defined. By the time a message reaches a Component, it is received as the exact raw sequence of bytes sent by the Component's counterpart. Individual components choose the best serialisation method and transmission frequency for their use case.","title":"The Medium is the Message"},{"location":"messaging/#scene-graph-as-a-bus","text":"Ubiq closely matches Unity's programming model. Since user code is placed in Components in Unity, networked objects in Ubiq are also Unity Components. Ubiq addresses have two elements: Object Id and Component Id. Object Id is analogous to the GameObject and Component Id is analgous to the Component script Type. Messages are only delivered between instances that have both the same Object Id and Component Id. This model allows complete seperation between the code that spawns and destroys Objects and the Components that make up those Objects. When an Object is created, only one identity needs to be generated and communicated, and instances of Components on different Objects don't need to disambiguate between eachother.","title":"Scene Graph as a Bus"},{"location":"messaging/#fan-out-at-the-network-layer","text":"When a Component transmits a message, it is recieved by every other Component with the same address (Object & Component Ids). This is the case regardless of how many instances there are with the same combination. Fanning out - or multicasting - the message is done at the network layer. Individual Components don't know how many counterparts they have.","title":"Fan-Out at the Network Layer"},{"location":"messaging/#example","text":"To see how these concepts work together, consider the example of an Avatar. The avatar will have one Object Id, and two Components, one for the Skeletal Animation and one for Eye Gaze. Each Component knows only it's Component Id, which must be distinct to avoid eye gaze messages being routed to the skeletal animation and vice versa. When the Avatar is created, the Avatar Spawner generates a new unqiue identity. It instantiates a prefab locally, and communicates its identity to the other peers, so that they also may instantiate the prefab. This identity becomes the Object Id. Each peer has an instance of the prefab with the new identity. This identity represents the players avatar. When the avatar changes, e.g. its skeleton is updated with tracking information, the avatars components send messages. These are received at remote peers by the avatar's counterparts, based on them having the same Object Ids. Within the Objects, messages are delivered to the correct Component based on the Component Id. The Avatar Spawner doesn't know which Components are on the Prefab, so only has to communicate one new identity to its peers. Netiher do the Components don't need to know which Prefab they belong to, or what other Components exist on the Object. They just exchange messages with their direct counterparts.","title":"Example"},{"location":"mkdocs/","text":"MkDocs Commands This page is for the Ubiq developers. This documentation is generated with MkDocs. For full documentation visit mkdocs.org . To keep linking between pages simple, try to keep all MD files in the docs/ directory. Images should be placed in images/ and all filenames should be GUIDS. Please delete images if you remove a reference to them. The exception is reusable assets such as logos, which have human-readable names. There is a special branch of Ubiq (\"Documentation\") which can be used to store Scenes and other assets that were set up for screenshots. mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Meta"},{"location":"mkdocs/#mkdocs-commands","text":"This page is for the Ubiq developers. This documentation is generated with MkDocs. For full documentation visit mkdocs.org . To keep linking between pages simple, try to keep all MD files in the docs/ directory. Images should be placed in images/ and all filenames should be GUIDS. Please delete images if you remove a reference to them. The exception is reusable assets such as logos, which have human-readable names. There is a special branch of Ubiq (\"Documentation\") which can be used to store Scenes and other assets that were set up for screenshots. mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"MkDocs Commands"},{"location":"networkidtype/","text":"Network and Component Types Network Ids Network Ids are 64-bit identifiers. They are represented by the Ubiq.Messaging.NetworkId structure in C# and the Messaging.NetworkId class in Javascript. In C# Ids are value types, and the equality operators are overridden. In Javascript they are reference types and must be explicitly compared using the static NetworkId.Compare method. NetworkId.Compare(message.objectId, server.objectId) Internally, the types are represented by two 32 bit integers. This is an implementation detail and should not be relied upon. The reason for using two 32 bit integers rather than one 64 bit long, is that Javascript only supports 53 bit integers. Binary vs Json In Javascript, NetworkId s must be handled in both their binary and Json forms. This is because Ubiq messages include the NetworkId in their binary header, while some Javascript services, such as the Room Server, accept NetworkId s as arguments. For example, a Json message would arrive containing the Id of an object that the Javascript code should send a message to. The Javascript code will need to convert that into a binary representation in order to build the header. Binary NetworkId s are converted to NetworkId class instances by the Message wrapper. From this point on any Javascript code can work with the object in its Json representation. NetworkId instances and generic Json objects representing a network Id can interoperate. Component Ids Component Ids are represented by ushort.","title":"Types"},{"location":"networkidtype/#network-and-component-types","text":"","title":"Network and Component Types"},{"location":"networkidtype/#network-ids","text":"Network Ids are 64-bit identifiers. They are represented by the Ubiq.Messaging.NetworkId structure in C# and the Messaging.NetworkId class in Javascript. In C# Ids are value types, and the equality operators are overridden. In Javascript they are reference types and must be explicitly compared using the static NetworkId.Compare method. NetworkId.Compare(message.objectId, server.objectId) Internally, the types are represented by two 32 bit integers. This is an implementation detail and should not be relied upon. The reason for using two 32 bit integers rather than one 64 bit long, is that Javascript only supports 53 bit integers.","title":"Network Ids"},{"location":"networkidtype/#binary-vs-json","text":"In Javascript, NetworkId s must be handled in both their binary and Json forms. This is because Ubiq messages include the NetworkId in their binary header, while some Javascript services, such as the Room Server, accept NetworkId s as arguments. For example, a Json message would arrive containing the Id of an object that the Javascript code should send a message to. The Javascript code will need to convert that into a binary representation in order to build the header. Binary NetworkId s are converted to NetworkId class instances by the Message wrapper. From this point on any Javascript code can work with the object in its Json representation. NetworkId instances and generic Json objects representing a network Id can interoperate.","title":"Binary vs Json"},{"location":"networkidtype/#component-ids","text":"Component Ids are represented by ushort.","title":"Component Ids"},{"location":"nexus/","text":"Nexus Overview The UCL VECG hosts multiple instances of the rendezvous server on nexus.cs.ucl.ac.uk. Different branches of this repository are checked on nexus and run on different ports. The checkouts are in /home/node and follow the format ubiq-[branch name] . Currently ubiq-master is running on 8004 . This is the primary, public server. It is expected and encouraged that feature branches are created, run on nexus temporarily for development, then removed when no longer needed. The following sections describe how Nexus is maintained by the VECG team. You do not need to follow this pattern to maintain your own server, but it may be instructive. Administration Access to nexus.cs.ucl.ac.uk is via SSH. The nodejs process is managed via pm2 . The relevant commands are: pm2 list (Shows running processes) pm2 log (Shows the logs) pm2 flush (Clears the logs) pm2 restart (Restarts the app, e.g. after an update) pm2 is responsible for restarting the nodejs process after a server restart. To save the state of the tasks that it will try to restore, give the command pm2 save . nodejs and pm2 run under the node account. All maintenance should be performed as node . The username/password is node/node. It is not possible to SSH directly as node; login with your CS credentials, then change user with su (i.e. $ su node ). All VECG members who request access will be given sudo permission. All members will be collaborators on the Github repository. Any member can add new members. Git The node account has been given access to the GitHub repository through a Deploy Key . This is a single-use SSH key associated with the repository. New When cloning a new copy for a branch, you must specify the folder as git will always clone into the repository name by default. For example: git clone --depth 1 git@github.com:UCL-VR/ubiq.git ubiq-master You can specify the branch name for the clone command ( git clone --depth 1 --branch master git@github.com:UCL-VR/ubiq.git ubiq-master ), or checkout the appropriate branch after. The --depth 1 command downloads only the HEAD , which is all that is needed to run the server. After cloning, navigate to ~/ubiq-[branch name]/Node/ and issue the commands: npm install pm2 start app.js --name \"ubiq-[branch name]\" The first installs the nodejs dependencies and the second creates the pm2 job with a unique name to identify the instance. Updating To update a checkout, enter the repository and issue git pull . node cannot write to the repository. Firewall Be aware when creating your own clones that you will need to open your chosen ports on the local firewall and reload it. To see the firewall rules on CentOS, give the command, sudo iptables -L -n -v --line-n The -n argument shows the port numbers, rather than showing the names of typical services that run on them. -v shows the interface, and --line-n shows line numbers, which will be important when adding rules. To add a new rule give the commands, sudo iptables -I INPUT 5 -p tcp --dport 8004 -j ACCEPT sudo service iptables save The number after INPUT indicates the line that the rule should be added at. The ACCEPT rule must come before the catch-all REJECT rule. For example, the REJECT rule is on line 11 below and will reject all packets not matching any of the rules above it. 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8006 6 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8005 7 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8004 8 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8003 9 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8002 10 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8001 11 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited The iptables save is for the iptables-service , which is installed on Nexus , and allows saving and automatically reloading firewall rules on reboot. Be aware also that opening the ports locally will not make them available on the public internet, but only via the CS VPN. Nexus has range 8000-8020 open on the CS and ISD firewalls. Legacy Versions When breaking changes are made, legacy versions of the server will be checked out with their last supported version number, e.g. ubiq-0.0.6 , and instances of these will be left running. The ports that they listen on will be incremented with each breaking change. Old clients will therefore continue to work, though old and new versions cannot communicate with eachother. Not all versions include breaking changes, so the sequence of legacy versions running is not continuous. The latest version is always ubiq-master . Currently ubiq-0.0.6 is running on 8001 . References https://upcloud.com/community/tutorials/configure-iptables-centos/","title":"Nexus"},{"location":"nexus/#nexus","text":"","title":"Nexus"},{"location":"nexus/#overview","text":"The UCL VECG hosts multiple instances of the rendezvous server on nexus.cs.ucl.ac.uk. Different branches of this repository are checked on nexus and run on different ports. The checkouts are in /home/node and follow the format ubiq-[branch name] . Currently ubiq-master is running on 8004 . This is the primary, public server. It is expected and encouraged that feature branches are created, run on nexus temporarily for development, then removed when no longer needed. The following sections describe how Nexus is maintained by the VECG team. You do not need to follow this pattern to maintain your own server, but it may be instructive.","title":"Overview"},{"location":"nexus/#administration","text":"Access to nexus.cs.ucl.ac.uk is via SSH. The nodejs process is managed via pm2 . The relevant commands are: pm2 list (Shows running processes) pm2 log (Shows the logs) pm2 flush (Clears the logs) pm2 restart (Restarts the app, e.g. after an update) pm2 is responsible for restarting the nodejs process after a server restart. To save the state of the tasks that it will try to restore, give the command pm2 save . nodejs and pm2 run under the node account. All maintenance should be performed as node . The username/password is node/node. It is not possible to SSH directly as node; login with your CS credentials, then change user with su (i.e. $ su node ). All VECG members who request access will be given sudo permission. All members will be collaborators on the Github repository. Any member can add new members.","title":"Administration"},{"location":"nexus/#git","text":"The node account has been given access to the GitHub repository through a Deploy Key . This is a single-use SSH key associated with the repository.","title":"Git"},{"location":"nexus/#new","text":"When cloning a new copy for a branch, you must specify the folder as git will always clone into the repository name by default. For example: git clone --depth 1 git@github.com:UCL-VR/ubiq.git ubiq-master You can specify the branch name for the clone command ( git clone --depth 1 --branch master git@github.com:UCL-VR/ubiq.git ubiq-master ), or checkout the appropriate branch after. The --depth 1 command downloads only the HEAD , which is all that is needed to run the server. After cloning, navigate to ~/ubiq-[branch name]/Node/ and issue the commands: npm install pm2 start app.js --name \"ubiq-[branch name]\" The first installs the nodejs dependencies and the second creates the pm2 job with a unique name to identify the instance.","title":"New"},{"location":"nexus/#updating","text":"To update a checkout, enter the repository and issue git pull . node cannot write to the repository.","title":"Updating"},{"location":"nexus/#firewall","text":"Be aware when creating your own clones that you will need to open your chosen ports on the local firewall and reload it. To see the firewall rules on CentOS, give the command, sudo iptables -L -n -v --line-n The -n argument shows the port numbers, rather than showing the names of typical services that run on them. -v shows the interface, and --line-n shows line numbers, which will be important when adding rules. To add a new rule give the commands, sudo iptables -I INPUT 5 -p tcp --dport 8004 -j ACCEPT sudo service iptables save The number after INPUT indicates the line that the rule should be added at. The ACCEPT rule must come before the catch-all REJECT rule. For example, the REJECT rule is on line 11 below and will reject all packets not matching any of the rules above it. 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8006 6 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8005 7 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8004 8 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8003 9 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8002 10 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8001 11 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited The iptables save is for the iptables-service , which is installed on Nexus , and allows saving and automatically reloading firewall rules on reboot. Be aware also that opening the ports locally will not make them available on the public internet, but only via the CS VPN. Nexus has range 8000-8020 open on the CS and ISD firewalls.","title":"Firewall"},{"location":"nexus/#legacy-versions","text":"When breaking changes are made, legacy versions of the server will be checked out with their last supported version number, e.g. ubiq-0.0.6 , and instances of these will be left running. The ports that they listen on will be incremented with each breaking change. Old clients will therefore continue to work, though old and new versions cannot communicate with eachother. Not all versions include breaking changes, so the sequence of legacy versions running is not continuous. The latest version is always ubiq-master . Currently ubiq-0.0.6 is running on 8001 .","title":"Legacy Versions"},{"location":"nexus/#references","text":"https://upcloud.com/community/tutorials/configure-iptables-centos/","title":"References"},{"location":"objectids/","text":"Object and Component Ids Network Object Ids are analogous to GameObject instance Ids, and are intended to be initialised late. For example, a spawner instantiates a prefab, then set its Id. Object Ids are represented by the NetworkId type. Component Ids are analogous to class types and are intended to be fixed at design time. They should be unique within a single application. Component Ids are set by the NetworkComponentId Attribute, and so Ubiq can infer the Id from the type. Component Ids are ushort . NetworkId Classes that are network objects implement the INetworkObject interface, which has one member, a get accessor for a NetworkId NetworkIds can be generated or set at design time. They will almost always be generated however. While NetworkId s are mutable, they may be cached in different places (e.g. in lookup tables) by both Ubiq and user code, so changing them after the late-initialisation is strongly discouraged. By design INetworkObject only specifies the get accessor, so code that changes an object's NetworkId will need access to the full type - as it should if it is capable of safely changing the id. The recommended pattern is to set the NetworkId when the interface is implemented, public NetworkId Id { get; } = NetworkId.Unique(); This prevents any code from changing the Id, even within the class itself. There are other patterns however depending on need. For example, the Avatar class initialises a unique Id, but also implements the set accessor, as remote instances will need to have their Ids set to match their player's counterpart. Performing initialisation with the option to override before Start() allows users to build scenes with Avatar instances in the Editor, but also to instantiate prefabs dynamically. public NetworkId Id { get; set; } = NetworkId.Unique(); The ISpawnable interface explicitly requires the set accessor, as spawned objects also need their Id set externally. public interface ISpawnable { NetworkId Id { set; } void OnSpawned(bool local); } In general, the guidelines are to: Set NetworkId s before or during Awake() . Never read an object's NetworkId before Start() Never change an unknown object's NetworkId . If a NetworkId changes, it must be re-registerd with NetworkScene::Register() , however be aware that this may not be sufficient as other components may have cached the object beforehand. ComponentIds Component Ids are fixed at design time and closely follow a particular type. If a Component Id is not explicitly set, it is automatically defined based on the full name of the type. For example, the full name of the NetworkSpawner as defined below is Ubiq.Samples.NetworkSpawner . namespace Ubiq.Samples { public class NetworkSpawner : MonoBehaviour, INetworkObject, INetworkComponent { } } The ushort is calculated using an MD5 hash, to ensure that the same value is resolved on different platforms. Component Ids can also be set using the NetworkComponentId attribute. Multiple Components may have the same Id, so long as the components will not be added to the same NetworkObject , though this is not recommended. Fixed Component Ids In the same way as a known, fixed location is needed for clients to rendezvous, some services, such as the Room Server, need to be defined ahead of time. These are given unique Object and Component Ids. Multicasting Implementation How fan-out is performed depends on the network architecture. In a mesh arrangement, all messages are transmitted on each connection by the Router object. In a client-server arrangement, such as with the Room Server, the server is responsible for forwarding messages to each peer in a room. Routing Implementation Object and Component Ids are concepts. In practice, Component instances register themselves with a Scene. This registration process infers the Object and Component Ids for that instance, and store them in a Context. This context is used to route the messages. Object Ids are inferred from the closest antecedent that implements INetworkObject.","title":"Object and Component Ids"},{"location":"objectids/#object-and-component-ids","text":"Network Object Ids are analogous to GameObject instance Ids, and are intended to be initialised late. For example, a spawner instantiates a prefab, then set its Id. Object Ids are represented by the NetworkId type. Component Ids are analogous to class types and are intended to be fixed at design time. They should be unique within a single application. Component Ids are set by the NetworkComponentId Attribute, and so Ubiq can infer the Id from the type. Component Ids are ushort .","title":"Object and Component Ids"},{"location":"objectids/#networkid","text":"Classes that are network objects implement the INetworkObject interface, which has one member, a get accessor for a NetworkId NetworkIds can be generated or set at design time. They will almost always be generated however. While NetworkId s are mutable, they may be cached in different places (e.g. in lookup tables) by both Ubiq and user code, so changing them after the late-initialisation is strongly discouraged. By design INetworkObject only specifies the get accessor, so code that changes an object's NetworkId will need access to the full type - as it should if it is capable of safely changing the id. The recommended pattern is to set the NetworkId when the interface is implemented, public NetworkId Id { get; } = NetworkId.Unique(); This prevents any code from changing the Id, even within the class itself. There are other patterns however depending on need. For example, the Avatar class initialises a unique Id, but also implements the set accessor, as remote instances will need to have their Ids set to match their player's counterpart. Performing initialisation with the option to override before Start() allows users to build scenes with Avatar instances in the Editor, but also to instantiate prefabs dynamically. public NetworkId Id { get; set; } = NetworkId.Unique(); The ISpawnable interface explicitly requires the set accessor, as spawned objects also need their Id set externally. public interface ISpawnable { NetworkId Id { set; } void OnSpawned(bool local); } In general, the guidelines are to: Set NetworkId s before or during Awake() . Never read an object's NetworkId before Start() Never change an unknown object's NetworkId . If a NetworkId changes, it must be re-registerd with NetworkScene::Register() , however be aware that this may not be sufficient as other components may have cached the object beforehand.","title":"NetworkId"},{"location":"objectids/#componentids","text":"Component Ids are fixed at design time and closely follow a particular type. If a Component Id is not explicitly set, it is automatically defined based on the full name of the type. For example, the full name of the NetworkSpawner as defined below is Ubiq.Samples.NetworkSpawner . namespace Ubiq.Samples { public class NetworkSpawner : MonoBehaviour, INetworkObject, INetworkComponent { } } The ushort is calculated using an MD5 hash, to ensure that the same value is resolved on different platforms. Component Ids can also be set using the NetworkComponentId attribute. Multiple Components may have the same Id, so long as the components will not be added to the same NetworkObject , though this is not recommended.","title":"ComponentIds"},{"location":"objectids/#fixed-component-ids","text":"In the same way as a known, fixed location is needed for clients to rendezvous, some services, such as the Room Server, need to be defined ahead of time. These are given unique Object and Component Ids.","title":"Fixed Component Ids"},{"location":"objectids/#multicasting-implementation","text":"How fan-out is performed depends on the network architecture. In a mesh arrangement, all messages are transmitted on each connection by the Router object. In a client-server arrangement, such as with the Room Server, the server is responsible for forwarding messages to each peer in a room.","title":"Multicasting Implementation"},{"location":"objectids/#routing-implementation","text":"Object and Component Ids are concepts. In practice, Component instances register themselves with a Scene. This registration process infers the Object and Component Ids for that instance, and store them in a Context. This context is used to route the messages. Object Ids are inferred from the closest antecedent that implements INetworkObject.","title":"Routing Implementation"},{"location":"objectownership/","text":"Additional Object and Networking Functionalities Ownership With this networked object, you will notice that you cannot move them in the editor or change their colour. The reason for this is that both objects are sending each other their position and any change you make gets overwritten by the incoming messages before it can go out. This situation where two changes race against each other is called a \"race condition\". One easy way to prevent this, is to give one of the network objects a flag that signals whether the object is owned by the local instance or controlled by a remote one. This is not only useful for interaction between the player and the object, but also for when the object is controlled by the physics system! Add a bool that signals whether the object is locally owned and should send or whether it is owned by a remote instance and should only receive. Add a if-clause that prevents the object from sending when not owned locally After that, it should look like this: Now, however, it must be determined somehow if the object was spawned locally or remote to set the owner flag accordingly. For objects spawned by the NetworkSpawner (see section \"Spawning Objects\" below), this is easy and described here. For objects that are part of the scenery and already present at the start of the game, the objects will somehow need to negotiate an owner or find another way to prevent a race condition. We leave that to your ingenuity ;-) Include Ubik.Samples and inherit ISpawnable Implement the Interface. It only consist of one function: OnSpawned(bool local). The parameter \"local\" is either true if the object is owned locally or false if it is a remote object. You can directly assign that to \"owner\".","title":"Ownership"},{"location":"objectownership/#additional-object-and-networking-functionalities","text":"","title":"Additional Object and Networking Functionalities"},{"location":"objectownership/#ownership","text":"With this networked object, you will notice that you cannot move them in the editor or change their colour. The reason for this is that both objects are sending each other their position and any change you make gets overwritten by the incoming messages before it can go out. This situation where two changes race against each other is called a \"race condition\". One easy way to prevent this, is to give one of the network objects a flag that signals whether the object is owned by the local instance or controlled by a remote one. This is not only useful for interaction between the player and the object, but also for when the object is controlled by the physics system! Add a bool that signals whether the object is locally owned and should send or whether it is owned by a remote instance and should only receive. Add a if-clause that prevents the object from sending when not owned locally After that, it should look like this: Now, however, it must be determined somehow if the object was spawned locally or remote to set the owner flag accordingly. For objects spawned by the NetworkSpawner (see section \"Spawning Objects\" below), this is easy and described here. For objects that are part of the scenery and already present at the start of the game, the objects will somehow need to negotiate an owner or find another way to prevent a race condition. We leave that to your ingenuity ;-) Include Ubik.Samples and inherit ISpawnable Implement the Interface. It only consist of one function: OnSpawned(bool local). The parameter \"local\" is either true if the object is owned locally or false if it is a remote object. You can directly assign that to \"owner\".","title":"Ownership"},{"location":"packaging/","text":"Packaging Overview The Unity side of the project can be built as a package for the Unity Package Manager. Releases Release numbers use SemVer. The version is to be put in the filename and the package.json file. The intention is that each release corresponds to a commit. To this end if you are making a new release version of the package: Make sure you have no modified files (check your git status - the script does this for you) Add a tag on your current commit with the release number, push the tag to the origin repo Building (Script) There's a simple build script included in the project. It's integrated with the Unity Editor. Access it through the taskbar: Ubik-dev -> Pack for Unity Package Manager Building (Manual) Building the package manually is quite painless. Check git status does not indicate any modified files Make a new folder and copy over the Editor, Runtime and Samples folders and the package.json and package.json.meta files Rename the Samples folder to Samples~ (this stops Unity importing it into the main package) Zip it! Name the zipped file ubik-{versionnumber}.zip","title":"Packaging"},{"location":"packaging/#packaging","text":"","title":"Packaging"},{"location":"packaging/#overview","text":"The Unity side of the project can be built as a package for the Unity Package Manager.","title":"Overview"},{"location":"packaging/#releases","text":"Release numbers use SemVer. The version is to be put in the filename and the package.json file. The intention is that each release corresponds to a commit. To this end if you are making a new release version of the package: Make sure you have no modified files (check your git status - the script does this for you) Add a tag on your current commit with the release number, push the tag to the origin repo","title":"Releases"},{"location":"packaging/#building-script","text":"There's a simple build script included in the project. It's integrated with the Unity Editor. Access it through the taskbar: Ubik-dev -> Pack for Unity Package Manager","title":"Building (Script)"},{"location":"packaging/#building-manual","text":"Building the package manually is quite painless. Check git status does not indicate any modified files Make a new folder and copy over the Editor, Runtime and Samples folders and the package.json and package.json.meta files Rename the Samples folder to Samples~ (this stops Unity importing it into the main package) Zip it! Name the zipped file ubik-{versionnumber}.zip","title":"Building (Manual)"},{"location":"reservedids/","text":"Common Ids A number of Ids are pre-assigned to common objects in Ubiq. These are listed below. Network Ids RoomServer: 0000-0000-0000-0001 NetworkSpawner : a369-2643-7725-a971 LogCollector: fc26-78b8-4498-9953 LogManager: 92e9-e831-8281-2761 Known Component Ids RoomClient : 1 AvatarManager : 2","title":"Reserved IDs"},{"location":"reservedids/#common-ids","text":"A number of Ids are pre-assigned to common objects in Ubiq. These are listed below.","title":"Common Ids"},{"location":"reservedids/#network-ids","text":"RoomServer: 0000-0000-0000-0001 NetworkSpawner : a369-2643-7725-a971 LogCollector: fc26-78b8-4498-9953 LogManager: 92e9-e831-8281-2761","title":"Network Ids"},{"location":"reservedids/#known-component-ids","text":"RoomClient : 1 AvatarManager : 2","title":"Known Component Ids"},{"location":"roomserverversioning/","text":"Versioning There is no such thing as an \"authoritative\" server in Ubiq. Components such as the Room Server implement services to fulfil a particular goal. They behave as traditional servers through some concepts: They have pre-defined Ids In some cases, such as the actual RoomServer Node App, they process messages themselves and change the messaing behaviour. Such services use pre-defined Ids and can make assumptions about how they will be used, but always at least assume that both themselves and their users are in a Ubiq mesh. Components like the RoomClient will bootstrap this by creating those initial connections. Each service then is responsible for maintaing, or not, compatability and version control.","title":"Versioning"},{"location":"roomserverversioning/#versioning","text":"There is no such thing as an \"authoritative\" server in Ubiq. Components such as the Room Server implement services to fulfil a particular goal. They behave as traditional servers through some concepts: They have pre-defined Ids In some cases, such as the actual RoomServer Node App, they process messages themselves and change the messaing behaviour. Such services use pre-defined Ids and can make assumptions about how they will be used, but always at least assume that both themselves and their users are in a Ubiq mesh. Components like the RoomClient will bootstrap this by creating those initial connections. Each service then is responsible for maintaing, or not, compatability and version control.","title":"Versioning"},{"location":"serverheartbeat/","text":"Heartbeat RoomClient instances will ping the RoomServer at a 1 Hz. If they do not receive a response after 5 seconds, they consider the server to have timed out, and will notify the user. Timeouts If a client drops a connection to a server, the server will inform all other peers by emitting OnPeerRemoved . The server will only remove a client when the underlying TCP connection has been closed. Until this time the client may re-appear. If a client connection breaks without shutting down cleanly, there may be a delay during which the Peer is in the room, but cannot exchange messages. Components should be robust to this. How they behave will depend on their use-case. For example, if a peer existed in the room but had no effect on it, there would be no need to detect this case at all. The Avatar class uses interruptions in its transform stream to detect a disconnected peer, and will hide an Avatar after a few seconds if no data is received. An easy way for Components to handle this case is to ensure they are created under a Peer's Avatar, in which case they will be enabled and disabled with the Avatar. RoomClient instances do not necessarily control the connections to RoomServer and so cannot detect if these are lost. RoomClient instances ping the RoomServer routinely and if they do not get a response after a set time, will disconnect the connections they are responsible before and consider the room left.","title":"Heartbeat and Timeouts"},{"location":"serverheartbeat/#heartbeat","text":"RoomClient instances will ping the RoomServer at a 1 Hz. If they do not receive a response after 5 seconds, they consider the server to have timed out, and will notify the user.","title":"Heartbeat"},{"location":"serverheartbeat/#timeouts","text":"If a client drops a connection to a server, the server will inform all other peers by emitting OnPeerRemoved . The server will only remove a client when the underlying TCP connection has been closed. Until this time the client may re-appear. If a client connection breaks without shutting down cleanly, there may be a delay during which the Peer is in the room, but cannot exchange messages. Components should be robust to this. How they behave will depend on their use-case. For example, if a peer existed in the room but had no effect on it, there would be no need to detect this case at all. The Avatar class uses interruptions in its transform stream to detect a disconnected peer, and will hide an Avatar after a few seconds if no data is received. An easy way for Components to handle this case is to ensure they are created under a Peer's Avatar, in which case they will be enabled and disabled with the Avatar. RoomClient instances do not necessarily control the connections to RoomServer and so cannot detect if these are lost. RoomClient instances ping the RoomServer routinely and if they do not get a response after a set time, will disconnect the connections they are responsible before and consider the room left.","title":"Timeouts"},{"location":"serverintroduction/","text":"Servers and Rooms Ubiq provides a Rooms system and a server. These work together to provide a fixed endpoint that allows users to rendezvous over the internet, where service discovery is impossible. The Rooms system - the RoomClient and RoomServer - provide the concepts of Rooms and Peers. A Peer is a remote player. A Room is a place that multiple Peers can join. The example Server implements a RoomServer that allows Peers to find and join Rooms, and facilitates message exchange between the Rooms members. Rooms and Messaging The purpose of rooms is to control which users exchange messages with which. At the messaging layer, Ubiq transmits messages across a Connection and expects the network to deliver them to matching objects. The connection made by the RoomClient to the Server is the same one used to deliver messages between networked objects. When the server receives a message, it forwards it to all other peers in the room. After connecting to the server, a client begins in an empty room. Its messages will not be forwarded to anyone. The RoomClient can join an existing room by exchanging messages with the RoomServer. The RoomServer is a 'virtual' networked object that exists on the server and listens for messages addressed to a particular Object/Component Id. Once the RoomClient has sucessfully joined a room via the RoomServer, messages will begin to be forwarded between that client and the other members. Rooms Rooms themselves are objects that exist in the RoomServer. Rooms contain a list of Peers, as well as a general purpose dictionary for storing low-frequency persistent information. Each Peer object contains the Socket used to communicate with the client. Services The RoomServer is one service that exists on the server. Other services include simple Blob management.","title":"Introduction"},{"location":"serverintroduction/#servers-and-rooms","text":"Ubiq provides a Rooms system and a server. These work together to provide a fixed endpoint that allows users to rendezvous over the internet, where service discovery is impossible. The Rooms system - the RoomClient and RoomServer - provide the concepts of Rooms and Peers. A Peer is a remote player. A Room is a place that multiple Peers can join. The example Server implements a RoomServer that allows Peers to find and join Rooms, and facilitates message exchange between the Rooms members.","title":"Servers and Rooms"},{"location":"serverintroduction/#rooms-and-messaging","text":"The purpose of rooms is to control which users exchange messages with which. At the messaging layer, Ubiq transmits messages across a Connection and expects the network to deliver them to matching objects. The connection made by the RoomClient to the Server is the same one used to deliver messages between networked objects. When the server receives a message, it forwards it to all other peers in the room. After connecting to the server, a client begins in an empty room. Its messages will not be forwarded to anyone. The RoomClient can join an existing room by exchanging messages with the RoomServer. The RoomServer is a 'virtual' networked object that exists on the server and listens for messages addressed to a particular Object/Component Id. Once the RoomClient has sucessfully joined a room via the RoomServer, messages will begin to be forwarded between that client and the other members.","title":"Rooms and Messaging"},{"location":"serverintroduction/#rooms","text":"Rooms themselves are objects that exist in the RoomServer. Rooms contain a list of Peers, as well as a general purpose dictionary for storing low-frequency persistent information. Each Peer object contains the Socket used to communicate with the client.","title":"Rooms"},{"location":"serverintroduction/#services","text":"The RoomServer is one service that exists on the server. Other services include simple Blob management.","title":"Services"},{"location":"serveroverview/","text":"Overview The Room Server service consists of a number of objects that work together to route messages to either the command and control interface on the server itself, or to other peers. RoomClient Connections The NetworkScene itself does not create any connections. In the Ubiq sample code, the RoomClient is responsible for making the initial connection to the rendezvous server. The RoomClient has a pre-shared IP and port, which it assumes points to an endpoint with a Room Server running. The Ubiq server Nexus runs a Room Server. When RoomClient starts up, it instructs the NetworkScene to make the connection. The underlying connection may be over TCP, WebSockets, or any other supported protocol. Once established the NetworkScene will assume it can be used to exchange Ubiq messages however. On the server, new connections are wrapped with a RoomPeer object. The RoomPeer is able to parse Ubiq messages. It also has references to the global RoomServer object. The RoomPeer acts as a gatekeeper. It parses messages intended for the RoomServer and calls the appropriate APIs. Other messages it forwards to the Room it is a member of. The APIs it invokes in response to RoomClient messages will cause the RoomServer object to move the RoomPeer between different rooms (or remove it from all rooms).","title":"Server Overview"},{"location":"serveroverview/#overview","text":"The Room Server service consists of a number of objects that work together to route messages to either the command and control interface on the server itself, or to other peers.","title":"Overview"},{"location":"serveroverview/#roomclient-connections","text":"The NetworkScene itself does not create any connections. In the Ubiq sample code, the RoomClient is responsible for making the initial connection to the rendezvous server. The RoomClient has a pre-shared IP and port, which it assumes points to an endpoint with a Room Server running. The Ubiq server Nexus runs a Room Server. When RoomClient starts up, it instructs the NetworkScene to make the connection. The underlying connection may be over TCP, WebSockets, or any other supported protocol. Once established the NetworkScene will assume it can be used to exchange Ubiq messages however. On the server, new connections are wrapped with a RoomPeer object. The RoomPeer is able to parse Ubiq messages. It also has references to the global RoomServer object. The RoomPeer acts as a gatekeeper. It parses messages intended for the RoomServer and calls the appropriate APIs. Other messages it forwards to the Room it is a member of. The APIs it invokes in response to RoomClient messages will cause the RoomServer object to move the RoomPeer between different rooms (or remove it from all rooms).","title":"RoomClient Connections"},{"location":"serversandrooms/","text":"Servers and Rooms Ubiq clients can connect directly to eachother, but most applications will use a room server. The room server is a central service which clients connect to and use to rendezvous with eachother. A server can host multiple Rooms . Rooms are a collection of users in a scene, who can talk to eachother and exchange messages. The RoomClient is used to find, join and leave rooms. The RoomClient must be provided with a server to connect to. The VECG team runs a public server, nexus.cs.ucl.ac.uk , or you can set up your own. RoomClient will connect to the server in the Default Server property on start-up, but you must join a room before you can communicate with other users. This can be done in the Editor through the button in the Inspector, through the RoomClient's API or through the example UI.","title":"Servers and Rooms"},{"location":"serversandrooms/#servers-and-rooms","text":"Ubiq clients can connect directly to eachother, but most applications will use a room server. The room server is a central service which clients connect to and use to rendezvous with eachother. A server can host multiple Rooms . Rooms are a collection of users in a scene, who can talk to eachother and exchange messages. The RoomClient is used to find, join and leave rooms. The RoomClient must be provided with a server to connect to. The VECG team runs a public server, nexus.cs.ucl.ac.uk , or you can set up your own. RoomClient will connect to the server in the Default Server property on start-up, but you must join a room before you can communicate with other users. This can be done in the Editor through the button in the Inspector, through the RoomClient's API or through the example UI.","title":"Servers and Rooms"},{"location":"serversetup/","text":"Setting up the server The server code is included in the Ubiq repository. After checking out the code, run npm install in the Node directory. The server can then be started. node app.js","title":"Running the server"},{"location":"serversetup/#setting-up-the-server","text":"The server code is included in the Ubiq repository. After checking out the code, run npm install in the Node directory. The server can then be started. node app.js","title":"Setting up the server"},{"location":"settingupvr/","text":"Setting Up Ubik for VR Ubiq uses Unity's XR Plug-in Management system for all samples. This allows you to enable a VR plugin matching your device and to interact with it through a unified interface. There is a quick guide below for each supported platform. Oculus or Windows Mixed Reality (desktop) In Unity, open the project settings window (Edit/Project Settings...) and go to the XR Plug-in Management menu. Enable the plug-in here - just tick either the Oculus or Windows Mixed Reality box. Also tick the box for \"Initialize XR on Startup\". OpenVR (desktop) 1. Note that while rendering and tracking works well, this subsystem is currently missing input from the hand controllers. Unfortunately, this is a limitation with the plugin and a fix does not seem to be on the horizon. 2. Follow the instructions to download the OpenVR Unity XR plug-in here: https://github.com/ValveSoftware/unity-xr-plugin/releases/tag/installer Oculus Quest 1. Install android build tools. In Unity Hub, click Installs on the left-hand menu. Click the three dots in the top right corner of the box for your Unity 2019.4.x installation and select Add modules from the dropdown. Select Android Build Support and both subsequent options ( Android SDK & NDK Tools and OpenJDK ). Wait for installation to complete, then re-open your project. 2. In Unity, open the project settings window (Edit/Project Settings...) and go to the XR Plug-in Management menu. 3. Click the Android tab and check the boxes for Oculus and \"Initialize XR on Startup\". 4. (Optional) To create your first build for the Quest, follow the Oculus Enable Device for Development and Testing guide: https://developer.oculus.com/documentation/unity/unity-enable-device/","title":"Setting Up VR"},{"location":"settingupvr/#setting-up-ubik-for-vr","text":"Ubiq uses Unity's XR Plug-in Management system for all samples. This allows you to enable a VR plugin matching your device and to interact with it through a unified interface. There is a quick guide below for each supported platform.","title":"Setting Up Ubik for VR"},{"location":"settingupvr/#oculus-or-windows-mixed-reality-desktop","text":"In Unity, open the project settings window (Edit/Project Settings...) and go to the XR Plug-in Management menu. Enable the plug-in here - just tick either the Oculus or Windows Mixed Reality box. Also tick the box for \"Initialize XR on Startup\".","title":"Oculus or Windows Mixed Reality (desktop)"},{"location":"settingupvr/#openvr-desktop","text":"1. Note that while rendering and tracking works well, this subsystem is currently missing input from the hand controllers. Unfortunately, this is a limitation with the plugin and a fix does not seem to be on the horizon. 2. Follow the instructions to download the OpenVR Unity XR plug-in here: https://github.com/ValveSoftware/unity-xr-plugin/releases/tag/installer","title":"OpenVR (desktop)"},{"location":"settingupvr/#oculus-quest","text":"1. Install android build tools. In Unity Hub, click Installs on the left-hand menu. Click the three dots in the top right corner of the box for your Unity 2019.4.x installation and select Add modules from the dropdown. Select Android Build Support and both subsequent options ( Android SDK & NDK Tools and OpenJDK ). Wait for installation to complete, then re-open your project. 2. In Unity, open the project settings window (Edit/Project Settings...) and go to the XR Plug-in Management menu. 3. Click the Android tab and check the boxes for Oculus and \"Initialize XR on Startup\". 4. (Optional) To create your first build for the Quest, follow the Oculus Enable Device for Development and Testing guide: https://developer.oculus.com/documentation/unity/unity-enable-device/","title":"Oculus Quest"},{"location":"spawningobjects/","text":"Spawning Objects To spawn an object in the local and all remote clients at the same time, there is a NetworkSpawner. There are two ways to spawn objects: NetworkSpawner.Spawn(\u2026) Use this for objects that are not meant to be persistent. Objects spawned through this function can only be seen by players that are already connected. A new player that joins later will not see them. NetworkSpawner.SpawnPersistent(\u2026) Use this for objects that are meant to be persistent. Objects spawned through this function will be stored by the server and the client of any new player receives a copy of this list to make sure the new player sees all the persistent objects already in the world. Note: The new object prefab needs to be known to the environment! For that, add it to the PrefabCatalogue of the SceneManager. If the scene manager does not have a catalogue yet, you can create one in the project window by right-clicking-\\>create-\\>Prefab catalogue You then have to drag it into the scene manager to use it.","title":"Object Spawning"},{"location":"spawningobjects/#spawning-objects","text":"To spawn an object in the local and all remote clients at the same time, there is a NetworkSpawner. There are two ways to spawn objects: NetworkSpawner.Spawn(\u2026) Use this for objects that are not meant to be persistent. Objects spawned through this function can only be seen by players that are already connected. A new player that joins later will not see them. NetworkSpawner.SpawnPersistent(\u2026) Use this for objects that are meant to be persistent. Objects spawned through this function will be stored by the server and the client of any new player receives a copy of this list to make sure the new player sees all the persistent objects already in the world. Note: The new object prefab needs to be known to the environment! For that, add it to the PrefabCatalogue of the SceneManager. If the scene manager does not have a catalogue yet, you can create one in the project window by right-clicking-\\>create-\\>Prefab catalogue You then have to drag it into the scene manager to use it.","title":"Spawning Objects"},{"location":"ubiqxrinteraction/","text":"Making an Object Graspable If you want to have your object being grabbable with the user's hands, you will have to inherit from IGraspable and implement Grasp(...) and Release(...) Making an Object Usable If you want your object to do something when the user presses the trigger button while holding it, you need to inherit from IUsable and implement Use(...) and UnUse(...)","title":"Interaction with Ubiq XR"},{"location":"ubiqxrinteraction/#making-an-object-graspable","text":"If you want to have your object being grabbable with the user's hands, you will have to inherit from IGraspable and implement Grasp(...) and Release(...)","title":"Making an Object Graspable"},{"location":"ubiqxrinteraction/#making-an-object-usable","text":"If you want your object to do something when the user presses the trigger button while holding it, you need to inherit from IUsable and implement Use(...) and UnUse(...)","title":"Making an Object Usable"},{"location":"webrtc/","text":"WebRTC and VOIP Real-time Audio in Ubiq is supported by WebRTC. WebRTC is the media stack supporting RTC (real-time communication) in modern web-browsers. WebRTC allows Ubiq to interoperate with browsers and second-party native applications on multiple platforms. WebRTC supports everything required for RTC except signalling, by design. The WebRTC native libraries make their own P2P connections using ICE, and drive the audio devices. Ubiq exchanges signalling messages on behalf of the media stack to support this. WebRTC was chosen as it is the only stack that interoperates with web-browsers. It is also the only way to exchange UDP with browsers. It is recommended to use Ubiq's Audio API, rather than work with WebRTC directly. Library Ubiq currently uses SIPSorcery's .NET WebRTC library . Unlike typical WebRTC implementations, this library does not include a full media stack. Ubiq provides a simple audio endpoint which integrates with the Unity audio system, allowing for microphone input and spatialised audio output. Operation WebRTC operates using PeerConnection objects. These objects manage the connectivity with one or more other peers. RTC occurs in a P2P fashion, but PeerConnection objects require an out-of-band signalling system to establish their own RTP connections. While PCs (PeerConnections) can form a one-to-many mesh themselves by fanning-out offer and answer messages, typically they operate in tandem. We assume PCs always form pairs. Negotiation WebRTC peers establish P2P RTP connections to pass audio, video and blob data through a process known as Interactive Connectivity Establishment (ICE). ICE is performed by having an out-of-band signalling system exchange SDP and ICE messages. SDP messages describe what streams a peer would like to send and consume, and in what format. ICE messages test different methods of direct connections that perform NAT and firewall traversal, until a preferred one is found. The PC API is based on callbacks. When a track is added or removed from a PC, it raises an event, OnNegotiationNeeded. This signals to the host application that it should initiate an exchange of SDP and ICE messages. The host does this by generating an Offer SDP message, and transmitting it to the counterpart PC. The PCs will themselves generate subsequent messages.","title":"WebRtc"},{"location":"webrtc/#webrtc-and-voip","text":"Real-time Audio in Ubiq is supported by WebRTC. WebRTC is the media stack supporting RTC (real-time communication) in modern web-browsers. WebRTC allows Ubiq to interoperate with browsers and second-party native applications on multiple platforms. WebRTC supports everything required for RTC except signalling, by design. The WebRTC native libraries make their own P2P connections using ICE, and drive the audio devices. Ubiq exchanges signalling messages on behalf of the media stack to support this. WebRTC was chosen as it is the only stack that interoperates with web-browsers. It is also the only way to exchange UDP with browsers. It is recommended to use Ubiq's Audio API, rather than work with WebRTC directly.","title":"WebRTC and VOIP"},{"location":"webrtc/#library","text":"Ubiq currently uses SIPSorcery's .NET WebRTC library . Unlike typical WebRTC implementations, this library does not include a full media stack. Ubiq provides a simple audio endpoint which integrates with the Unity audio system, allowing for microphone input and spatialised audio output.","title":"Library"},{"location":"webrtc/#operation","text":"WebRTC operates using PeerConnection objects. These objects manage the connectivity with one or more other peers. RTC occurs in a P2P fashion, but PeerConnection objects require an out-of-band signalling system to establish their own RTP connections. While PCs (PeerConnections) can form a one-to-many mesh themselves by fanning-out offer and answer messages, typically they operate in tandem. We assume PCs always form pairs.","title":"Operation"},{"location":"webrtc/#negotiation","text":"WebRTC peers establish P2P RTP connections to pass audio, video and blob data through a process known as Interactive Connectivity Establishment (ICE). ICE is performed by having an out-of-band signalling system exchange SDP and ICE messages. SDP messages describe what streams a peer would like to send and consume, and in what format. ICE messages test different methods of direct connections that perform NAT and firewall traversal, until a preferred one is found. The PC API is based on callbacks. When a track is added or removed from a PC, it raises an event, OnNegotiationNeeded. This signals to the host application that it should initiate an exchange of SDP and ICE messages. The host does this by generating an Offer SDP message, and transmitting it to the counterpart PC. The PCs will themselves generate subsequent messages.","title":"Negotiation"},{"location":"xrinteraction/","text":"XR Interaction Ubiq includes a straightforward XR interaction framework. This supports high level actions such as Using and Grasping 2D and 3D objects, as well as interacting with the Unity UI system . Ubiq is not dependent on its own interaction system, and it is expected users may utilise the Unity XR Interaction Toolkit , MRTK , VRTK or another system for advanced functionality. The Ubiq system is intended to support common XR requirements however, while being very simple to use, and transparently cross-platform. All the Ubiq Samples are created with the Ubiq interaction system. Cross Platform Support The Ubiq interaction system is designed to work on both the desktop and in XR. This is achieved by maintaining two sets of input processing Components, that only respond to keyboard & mouse interactions, and XR controller interactions, respectively. These Components are designed to co-exist on one set of GameObjects, allowing the same Player Prefab to be used for desktop and XR applications with no change. For the interactables - 3D objects and 2D controls - identical events are recieved regardless of the source, so user code will work both for XR and the desktop transparently. 3D Interaction Interacting with 3D objects is action based . Users can Use or Grasp objects. What these actions do is entirely up to user code. For example, users could Use a button which spawns an object or turns on a light. They could Grasp a box which attaches to their hand, or a door which swings around an axis. To implement these behaviours, Components implement IUsable or IGraspable . They will then recieve callbacks to Use() / UnUse() and Grasp() / Release() , respectively. In XR, Players Use or Grasp objects by putting their controllers on an object and using the Trigger and Grip buttons. On the Desktop, users can use the cursor to click on objects with the Left or Middle mouse buttons. Components implementing IUsable and IGraspable must be attached to objects with Colliders, though they do not need a RigidBody. Hands The methods of IUsable and IGraspable are passed Hand instances. Hand represents an entity in 3D space (a MonoBehaviour ) that can interact with other 3D objects. Other than existing in 3D, the Hand type is very abstract. It mainly exists to provide a 3D anchor, and to allow Components to distinguish between different controllers. A Hand does not have to have any physical presence (a RigidBody, or Collider). Implementations of IUsable and IGraspable should be prepared to be used or grasped by multiple Hand instances simultaneously. Graspers and Users Calls to the IUsable and IGraspable implementations are made by the UsableObjectUser and GraspableObjectGrasper Components. These rely on the HandController Component, which implements the XR controller tracking and input processing based on the Unity XR namespace. There are desktop equivalents of UsableObjectUser and GraspableObjectGrasper . These references are to the concrete types and so it is not currently possible to use UsableObjectUser or GraspableObjectGrasper with custom hand implementations. Though it is possible to re-implement them and pass a custom Hand subclass to the IUsable and IGraspable implementations. 2D Interaction The Ubiq XR interaction integrates with Unity's UI system. Players can raycast from their hands to interact with Unity Canvases and controls. To enable Ubiq XR interaction with a Canvas, add the XRUICanvas component to it. Once this Component is added users can interact with the Unity controls using raycasts from the controllers, or the mouse cursor on the desktop. When using the XRUICanvas an EventSystem is no longer required. Cameras are not required either on World Space Canvases, allowing them to be declared in Prefabs and instantiated dynamically. Raycasters The 2D and 3D interaction mechanisms are separate. UI interaction is performed through UIRaycasters. There are XR and Desktop raycasters ( XRUIRaycaster and DesktopUIRaycaster ). Instances of both are attached to the sample Player Prefab. Player Controller Users move through the world using Player Controllers. The Samples contain a Player Prefab with a camera and two hands. Player Controllers can move linearly or teleport. Interaction always occurs through a Hand instance, so a Player Controller is not technically necessary.","title":"Interaction"},{"location":"xrinteraction/#xr-interaction","text":"Ubiq includes a straightforward XR interaction framework. This supports high level actions such as Using and Grasping 2D and 3D objects, as well as interacting with the Unity UI system . Ubiq is not dependent on its own interaction system, and it is expected users may utilise the Unity XR Interaction Toolkit , MRTK , VRTK or another system for advanced functionality. The Ubiq system is intended to support common XR requirements however, while being very simple to use, and transparently cross-platform. All the Ubiq Samples are created with the Ubiq interaction system.","title":"XR Interaction"},{"location":"xrinteraction/#cross-platform-support","text":"The Ubiq interaction system is designed to work on both the desktop and in XR. This is achieved by maintaining two sets of input processing Components, that only respond to keyboard & mouse interactions, and XR controller interactions, respectively. These Components are designed to co-exist on one set of GameObjects, allowing the same Player Prefab to be used for desktop and XR applications with no change. For the interactables - 3D objects and 2D controls - identical events are recieved regardless of the source, so user code will work both for XR and the desktop transparently.","title":"Cross Platform Support"},{"location":"xrinteraction/#3d-interaction","text":"Interacting with 3D objects is action based . Users can Use or Grasp objects. What these actions do is entirely up to user code. For example, users could Use a button which spawns an object or turns on a light. They could Grasp a box which attaches to their hand, or a door which swings around an axis. To implement these behaviours, Components implement IUsable or IGraspable . They will then recieve callbacks to Use() / UnUse() and Grasp() / Release() , respectively. In XR, Players Use or Grasp objects by putting their controllers on an object and using the Trigger and Grip buttons. On the Desktop, users can use the cursor to click on objects with the Left or Middle mouse buttons. Components implementing IUsable and IGraspable must be attached to objects with Colliders, though they do not need a RigidBody.","title":"3D Interaction"},{"location":"xrinteraction/#hands","text":"The methods of IUsable and IGraspable are passed Hand instances. Hand represents an entity in 3D space (a MonoBehaviour ) that can interact with other 3D objects. Other than existing in 3D, the Hand type is very abstract. It mainly exists to provide a 3D anchor, and to allow Components to distinguish between different controllers. A Hand does not have to have any physical presence (a RigidBody, or Collider). Implementations of IUsable and IGraspable should be prepared to be used or grasped by multiple Hand instances simultaneously.","title":"Hands"},{"location":"xrinteraction/#graspers-and-users","text":"Calls to the IUsable and IGraspable implementations are made by the UsableObjectUser and GraspableObjectGrasper Components. These rely on the HandController Component, which implements the XR controller tracking and input processing based on the Unity XR namespace. There are desktop equivalents of UsableObjectUser and GraspableObjectGrasper . These references are to the concrete types and so it is not currently possible to use UsableObjectUser or GraspableObjectGrasper with custom hand implementations. Though it is possible to re-implement them and pass a custom Hand subclass to the IUsable and IGraspable implementations.","title":"Graspers and Users"},{"location":"xrinteraction/#2d-interaction","text":"The Ubiq XR interaction integrates with Unity's UI system. Players can raycast from their hands to interact with Unity Canvases and controls. To enable Ubiq XR interaction with a Canvas, add the XRUICanvas component to it. Once this Component is added users can interact with the Unity controls using raycasts from the controllers, or the mouse cursor on the desktop. When using the XRUICanvas an EventSystem is no longer required. Cameras are not required either on World Space Canvases, allowing them to be declared in Prefabs and instantiated dynamically.","title":"2D Interaction"},{"location":"xrinteraction/#raycasters","text":"The 2D and 3D interaction mechanisms are separate. UI interaction is performed through UIRaycasters. There are XR and Desktop raycasters ( XRUIRaycaster and DesktopUIRaycaster ). Instances of both are attached to the sample Player Prefab.","title":"Raycasters"},{"location":"xrinteraction/#player-controller","text":"Users move through the world using Player Controllers. The Samples contain a Player Prefab with a camera and two hands. Player Controllers can move linearly or teleport. Interaction always occurs through a Hand instance, so a Player Controller is not technically necessary.","title":"Player Controller"},{"location":"xruidesktop/","text":"The Ubiq sample code includes both desktop and XR interation. The Desktop and XR Interaction is implemented in separate components. The Desktop Components only respond to keyboard and mouse inputs, and the XR Components only to XR controllers. This allows the Components for both to exist in parallel and the same Player Prefab to function on the Desktop and in XR without any change. Desktop Controls On the Desktop, the Mouse Cursor will be visible by default. Navigation The WSAD keys can be used to move around the environment. Hold the Right Mouse button to turn left and right or look up and down. Teleport by holding the Alt key. The hand which controls the teleport ray can be rotated by holding the Shift Key and moving the mouse. UI UI components can be interacted with by clicking them as if in a regular desktop GUI application. Usable Usable objects can be Used by holding the Left Mouse Button. They will be Unused when the mouse button is released. Graspable Graspable objects can be grasped by middle-clicking once. They can be ungrasped by clicking again (either in empty space, or on a new Graspable).","title":"Xruidesktop"},{"location":"xruidesktop/#desktop-controls","text":"On the Desktop, the Mouse Cursor will be visible by default.","title":"Desktop Controls"},{"location":"xruidesktop/#navigation","text":"The WSAD keys can be used to move around the environment. Hold the Right Mouse button to turn left and right or look up and down. Teleport by holding the Alt key. The hand which controls the teleport ray can be rotated by holding the Shift Key and moving the mouse.","title":"Navigation"},{"location":"xruidesktop/#ui","text":"UI components can be interacted with by clicking them as if in a regular desktop GUI application.","title":"UI"},{"location":"xruidesktop/#usable","text":"Usable objects can be Used by holding the Left Mouse Button. They will be Unused when the mouse button is released.","title":"Usable"},{"location":"xruidesktop/#graspable","text":"Graspable objects can be grasped by middle-clicking once. They can be ungrasped by clicking again (either in empty space, or on a new Graspable).","title":"Graspable"}]}